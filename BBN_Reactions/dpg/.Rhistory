library("inlabru", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
ggplot() +
gg(gorillas$mesh) +
gg(gorillas$nests) +
gg(gorillas$boundary) +
coord_fixed()
if (require("INLA", quietly = TRUE)) {
# Define SPDE prior
matern <- inla.spde2.pcmatern(gorillas$mesh,
prior.sigma = c(0.1, 0.01),
prior.range = c(5, 0.01))
# Define domain of the LGCP as well as the model components (spatial SPDE effect and Intercept)
cmp <- coordinates ~ mySmooth(map = coordinates, model = matern) + Intercept
# Fit the model
fit <- lgcp(cmp, gorillas$nests, samplers = gorillas$boundary)
# Predict the spatial intensity surface
lambda <- predict(fit, pixels(gorillas$mesh), ~ exp(mySmooth + Intercept))
# Plot the intensity
ggplot() +
gg(lambda) +
gg(gorillas$mesh) +
gg(gorillas$nests) +
gg(gorillas$boundary) +
coord_fixed()
}
matern
lambda
fit
gorillas
fit <- lgcp(cmp, gorillas$nests, samplers = gorillas$boundary)
cmp
matern
gorillas
######################################################################
# MCMC_Dpg.R
#
# conditions:
# - relationship between x and y given by theory [table]
# - theory relation from Marcucci et al.
#
# purpose:
# - fit a theoretical model to data
#
# details:
# - x data have no error; only y data have errors
# - different data sets are statistically independent
# - includes systematic errors in all sets [n.norm]
# - includes robust regression [outliers]
# - true relationship between variables is given by nuclear theory,
#   assuming only a single [scaling] parameter [a.scale]
######################################################################
# preparation: remove all variables from the work space
rm(list=ls())
# import jags package
library('rjags')
library(magicaxis)
## for block updating [we do not need to center predictor variables]
load.module("glm")
# random number seed
#set.seed(123)
######################################################################
## FUNCTIONS
######################################################################
# error bars
# w is the width of perpendicular end bars on errors; set to zero
add.error.bars <- function(X,Y,dX,dY,w,col){
X0 = X;
Y0 = (Y-dY);
X1 =X;
Y1 = (Y+dY);
arrows(X0, Y0, X1, Y1, lwd=2, code=3, angle=90, length=w, col=col);
Y0 = Y;
X0 = (X-dX);
Y1 =Y;
X1 = (X+dX);
arrows(X0, Y0, X1, Y1, lwd=2, code=3, angle=90, length=w, col=col);
}
######################################################################
# DATA INPUT
######################################################################
# data input; the input is of the form: obsx, obsy, errobsy, where the
# latter is the individual statistical error of each datum [i];
# energy is in MeV, S-factor in MeVb
## DATA SET 1: ma97a
obsx1 <-    c(7.490E-02, 1.070E-01, 1.330E-01, 1.730E-01)
obsy1    <- c(6.850E-07, 7.080E-07, 9.560E-07, 1.260E-06)
errobsy1 <- c(7.020E-08, 6.840E-08, 8.400E-08, 9.820E-08)
## DATA SET 2: bys08a
obsx2 <-    c(8.280E-03, 9.490E-03, 10.10E-03)
obsy2    <- c(2.370E-07, 2.770E-07, 2.980E-07)
errobsy2 <- c(7.100E-08, 6.400E-08, 6.500E-08)
## DATA SET 3: sch97a
obsx3 <-    c(1.000E-02, 1.670E-02, 2.330E-02, 3.000E-02, 3.670E-02, 4.330E-02,
5.000E-02)
obsy3    <- c(2.425E-07, 2.740E-07, 3.452E-07, 3.974E-07, 4.452E-07, 4.738E-07,
4.744E-07)
errobsy3 <- c(1.250E-08, 7.500E-09, 6.500E-09, 6.100E-09, 5.700E-09, 7.200E-09,
6.400E-09)
## DATA SET 4: cas02a
obsx4 <-    c( 2.600E-03, 3.200E-03, 3.200E-03, 3.800E-03, 4.200E-03,
4.600E-03, 4.600E-03, 5.200E-03, 5.800E-03, 6.100E-03, 6.500E-03,
6.700E-03, 7.200E-03, 7.800E-03, 8.400E-03, 8.500E-03, 9.100E-03,
9.100E-03, 9.700E-03, 9.800E-03, 1.040E-02, 1.040E-02, 1.050E-02,
1.060E-02, 1.120E-02, 1.120E-02, 1.190E-02, 1.190E-02, 1.230E-02,
1.240E-02, 1.320E-02, 1.320E-02, 1.380E-02, 1.440E-02, 1.460E-02,
1.500E-02, 1.580E-02, 1.590E-02, 1.630E-02, 1.720E-02, 1.720E-02,
1.760E-02, 1.850E-02, 1.860E-02, 1.910E-02, 1.970E-02, 1.990E-02,
1.980E-02, 2.040E-02, 2.120E-02)
obsy4    <- c( 1.590E-07, 2.370E-07, 2.560E-07, 2.420E-07, 2.330E-07,
2.290E-07, 2.510E-07, 2.490E-07, 2.430E-07, 2.520E-07, 2.620E-07,
2.610E-07, 2.690E-07, 2.730E-07, 2.730E-07, 2.640E-07, 2.620E-07,
2.710E-07, 2.700E-07, 2.790E-07, 3.010E-07, 2.850E-07, 2.900E-07,
2.860E-07, 2.880E-07, 2.800E-07, 2.900E-07, 2.890E-07, 2.770E-07,
2.890E-07, 3.000E-07, 2.680E-07, 3.110E-07, 2.900E-07, 3.460E-07,
2.990E-07, 2.820E-07, 3.250E-07, 2.960E-07, 3.140E-07, 3.390E-07,
3.020E-07, 3.240E-07, 3.550E-07, 3.250E-07, 3.280E-07, 3.280E-07,
3.320E-07, 3.090E-07, 3.280E-07)
errobsy4 <- c( 4.900E-08, 4.000E-08, 3.800E-08, 2.900E-08, 1.300E-08,
1.500E-08, 1.500E-08, 1.800E-08, 1.500E-08, 1.300E-08, 1.100E-08,
1.300E-08, 1.100E-08, 9.700E-09, 9.170E-08, 1.700E-08, 4.200E-08,
1.900E-08, 1.800E-08, 1.600E-08, 6.200E-08, 1.900E-08, 5.800E-08,
1.500E-08, 3.000E-08, 1.400E-08, 3.100E-08, 2.800E-08, 2.400E-08,
2.500E-08, 2.500E-08, 2.700E-08, 2.200E-08, 1.900E-08, 2.400E-08,
2.400E-08, 3.400E-08, 1.600E-08, 2.000E-08, 2.500E-08, 1.400E-08,
1.800E-08, 2.200E-08, 1.400E-08, 1.900E-08, 1.800E-08, 2.200E-08,
3.100E-08, 1.700E-08, 1.200E-08)
######################################################################
# INPUT OF THEORY MODEL [MARCUCCI et al.]
######################################################################
# E is in MeV, S is in eV b; convert to MeV and MeV b, respectively
theory <- read.table("Marcucci2005.dat", header=FALSE)
interp.x <- theory[,1]
interp.y <- theory[,2] * 1e-6
# we will use JAGS interp.lin function to use this theoretical S-factor:
#
# - the columns of this table define vectors x and y
# - a single point is given by x_i, y_i
# - interp.lin gives the y value for the x value provided as argument e,
#   interp.lin(e, x, y)
######################################################################
# rjags ----->
######################################################################
cat('model {
###################
# LIKELIHOODS
###################
# systematic error as normalization factor y.norm...
for (i in 1:length(obsx1)) {
#
# S-FACTOR
# ...subject to extrinsic scatter:
obsy1[i] ~ dnorm(ya1[i], pow(yscat1, -2))
# ...subject to stat uncertainties:
ya1[i] ~ dnorm(ym1[i], pow(errobsy1[i], -2))
# ...subject to syst uncertainties:
ym1[i] <- y.norm1 * yt1[i]
# true S-factor [calculated from theory and then scaled]:
yt1[i] <- a.scale * interp.lin(obsx1[i], interp.x, interp.y)
}
for (i in 1:length(obsx2)) {
#
# S-FACTOR
# ...subject to extrinsic scatter:
obsy2[i] ~ dnorm(ya2[i], pow(yscat2, -2))
# ...subject to stat uncertainties:
ya2[i] ~ dnorm(ym2[i], pow(errobsy2[i], -2))
# ...subject to syst uncertainties:
ym2[i] <- y.norm2 * yt2[i]
# true S-factor [calculated from theory and then scaled]:
yt2[i] <- a.scale * interp.lin(obsx2[i], interp.x, interp.y)
}
for (i in 1:length(obsx3)) {
#
# S-FACTOR
# ...subject to extrinsic scatter:
obsy3[i] ~ dnorm(ya3[i], pow(yscat3, -2))
# ...subject to stat uncertainties:
ya3[i] ~ dnorm(ym3[i], pow(errobsy3[i], -2))
# ...subject to syst uncertainties:
ym3[i] <- y.norm3 * yt3[i]
# true S-factor [calculated from theory and then scaled]:
yt3[i] <- a.scale * interp.lin(obsx3[i], interp.x, interp.y)
}
for (i in 1:length(obsx4)) {
#
# S-FACTOR
# ...subject to extrinsic scatter:
obsy4[i] ~ dnorm(ya4[i], pow(yscat4, -2))
# ...subject to stat uncertainties:
ya4[i] ~ dnorm(ym4[i], pow(errobsy4[i], -2))
# ...subject to syst uncertainties:
ym4[i] <- y.norm4 * yt4[i]
# true S-factor [calculated from theory and then scaled]:
yt4[i] <- a.scale * interp.lin(obsx4[i], interp.x, interp.y)
}
###################
# PRIORS
###################
### scaling factor of theory [a.scale]
a.scale ~ dnorm(0.0, pow(10, -2))T(0,)        #  "a.scale" cannot become negative!
# extrinsic scatter in S-factor
# what happens to likelihood if yscat = 4e-6 ??
yscat1 ~ dnorm(0.0, pow(2e-6, -2))T(0,)       # sigma is 2e-6 MeVb
yscat2 ~ dnorm(0.0, pow(2e-6, -2))T(0,)
yscat3 ~ dnorm(0.0, pow(2e-6, -2))T(0,)
yscat4 ~ dnorm(0.0, pow(2e-6, -2))T(0,)
# systematic normalization factor for S-factor:
# log(): natural logarithm
y.norm1 ~ dlnorm(logmu1, pow(logsigma1, -2))
logmu1 <- log(1.0)      # median of factor uncertainty is 1.0
logsigma1 <- log(1.09)  # factor uncertainty is 1.09, i.e. 9% for MA97
y.norm2 ~ dlnorm(logmu2, pow(logsigma2, -2))
logmu2 <- log(1.0)      # median of factor uncertainty is 1.0
logsigma2 <- log(1.08)  # factor uncertainty is <1.08, i.e., <8% for BYS08
# we are using "8%", not "<8%"
y.norm3 ~ dlnorm(logmu3, pow(logsigma3, -2))
logmu3 <- log(1.0)      # median of factor uncertainty is 1.0
logsigma3 <- log(1.09)  # factor uncertainty is 1.09, i.e., 9% for SCH97
y.norm4 ~ dlnorm(logmu4, pow(logsigma4, -2))
logmu4 <- log(1.0)      # median of factor uncertainty is 1.0
logsigma4 <- log(1.045) # factor uncertainty is 1.045, i.e., 4.5% for CAS02
}', file={f <- tempfile()})
# dunif(min=0, max=1): gives uniform density
# pow(a,b) = a^b
######################################################################
# n.adapt:  number of iterations in the chain for adaptation
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# update(): performs the burn-in on each chain by running the MCMC for
#           n.burn iterations without saving any of the posterior samples
# coda.samples(): runs each MCMC chain for the number of iterations
#           specified by n.iter, but it does not save every iteration;
#           instead, it saves only ever nth iteration, where n is given
#           by thin
# n.chains: number of mcmc chains
n.chains <- 3
n.adapt  <- 5000
n.burn   <- 5000
n.iter   <- 10000
thin     <- 1
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model;
#
ourmodel <- jags.model(f, data = list(        ## jags wants all data in a list
'obsx1' = obsx1, 'obsy1' = obsy1, 'errobsy1' = errobsy1,
'obsx2' = obsx2, 'obsy2' = obsy2, 'errobsy2' = errobsy2,
'obsx3' = obsx3, 'obsy3' = obsy3, 'errobsy3' = errobsy3,
'obsx4' = obsx4, 'obsy4' = obsy4, 'errobsy4' = errobsy4,
'interp.x' = interp.x, 'interp.y' = interp.y
),
n.chains = n.chains, n.adapt = n.adapt)
update(ourmodel, n.burn)
# variable.names are variables to be recorded in output file of samples
mcmcChain <- coda.samples(ourmodel,
variable.names=c(
'a.scale',
'y.norm1', 'y.norm2', 'y.norm3', 'y.norm4',
'yscat1',  'yscat2',  'yscat3',  'yscat4'
),
n.iter=n.iter, thin=thin)
setwd("~/Documents/GitHub/Bayesian_Nuclear/BBN_Reactions/dpg")
######################################################################
# MCMC_Dpg.R
#
# conditions:
# - relationship between x and y given by theory [table]
# - theory relation from Marcucci et al.
#
# purpose:
# - fit a theoretical model to data
#
# details:
# - x data have no error; only y data have errors
# - different data sets are statistically independent
# - includes systematic errors in all sets [n.norm]
# - includes robust regression [outliers]
# - true relationship between variables is given by nuclear theory,
#   assuming only a single [scaling] parameter [a.scale]
######################################################################
# preparation: remove all variables from the work space
rm(list=ls())
# import jags package
library('rjags')
library(magicaxis)
## for block updating [we do not need to center predictor variables]
load.module("glm")
# random number seed
#set.seed(123)
######################################################################
## FUNCTIONS
######################################################################
# error bars
# w is the width of perpendicular end bars on errors; set to zero
add.error.bars <- function(X,Y,dX,dY,w,col){
X0 = X;
Y0 = (Y-dY);
X1 =X;
Y1 = (Y+dY);
arrows(X0, Y0, X1, Y1, lwd=2, code=3, angle=90, length=w, col=col);
Y0 = Y;
X0 = (X-dX);
Y1 =Y;
X1 = (X+dX);
arrows(X0, Y0, X1, Y1, lwd=2, code=3, angle=90, length=w, col=col);
}
######################################################################
# DATA INPUT
######################################################################
# data input; the input is of the form: obsx, obsy, errobsy, where the
# latter is the individual statistical error of each datum [i];
# energy is in MeV, S-factor in MeVb
## DATA SET 1: ma97a
obsx1 <-    c(7.490E-02, 1.070E-01, 1.330E-01, 1.730E-01)
obsy1    <- c(6.850E-07, 7.080E-07, 9.560E-07, 1.260E-06)
errobsy1 <- c(7.020E-08, 6.840E-08, 8.400E-08, 9.820E-08)
## DATA SET 2: bys08a
obsx2 <-    c(8.280E-03, 9.490E-03, 10.10E-03)
obsy2    <- c(2.370E-07, 2.770E-07, 2.980E-07)
errobsy2 <- c(7.100E-08, 6.400E-08, 6.500E-08)
## DATA SET 3: sch97a
obsx3 <-    c(1.000E-02, 1.670E-02, 2.330E-02, 3.000E-02, 3.670E-02, 4.330E-02,
5.000E-02)
obsy3    <- c(2.425E-07, 2.740E-07, 3.452E-07, 3.974E-07, 4.452E-07, 4.738E-07,
4.744E-07)
errobsy3 <- c(1.250E-08, 7.500E-09, 6.500E-09, 6.100E-09, 5.700E-09, 7.200E-09,
6.400E-09)
## DATA SET 4: cas02a
obsx4 <-    c( 2.600E-03, 3.200E-03, 3.200E-03, 3.800E-03, 4.200E-03,
4.600E-03, 4.600E-03, 5.200E-03, 5.800E-03, 6.100E-03, 6.500E-03,
6.700E-03, 7.200E-03, 7.800E-03, 8.400E-03, 8.500E-03, 9.100E-03,
9.100E-03, 9.700E-03, 9.800E-03, 1.040E-02, 1.040E-02, 1.050E-02,
1.060E-02, 1.120E-02, 1.120E-02, 1.190E-02, 1.190E-02, 1.230E-02,
1.240E-02, 1.320E-02, 1.320E-02, 1.380E-02, 1.440E-02, 1.460E-02,
1.500E-02, 1.580E-02, 1.590E-02, 1.630E-02, 1.720E-02, 1.720E-02,
1.760E-02, 1.850E-02, 1.860E-02, 1.910E-02, 1.970E-02, 1.990E-02,
1.980E-02, 2.040E-02, 2.120E-02)
obsy4    <- c( 1.590E-07, 2.370E-07, 2.560E-07, 2.420E-07, 2.330E-07,
2.290E-07, 2.510E-07, 2.490E-07, 2.430E-07, 2.520E-07, 2.620E-07,
2.610E-07, 2.690E-07, 2.730E-07, 2.730E-07, 2.640E-07, 2.620E-07,
2.710E-07, 2.700E-07, 2.790E-07, 3.010E-07, 2.850E-07, 2.900E-07,
2.860E-07, 2.880E-07, 2.800E-07, 2.900E-07, 2.890E-07, 2.770E-07,
2.890E-07, 3.000E-07, 2.680E-07, 3.110E-07, 2.900E-07, 3.460E-07,
2.990E-07, 2.820E-07, 3.250E-07, 2.960E-07, 3.140E-07, 3.390E-07,
3.020E-07, 3.240E-07, 3.550E-07, 3.250E-07, 3.280E-07, 3.280E-07,
3.320E-07, 3.090E-07, 3.280E-07)
errobsy4 <- c( 4.900E-08, 4.000E-08, 3.800E-08, 2.900E-08, 1.300E-08,
1.500E-08, 1.500E-08, 1.800E-08, 1.500E-08, 1.300E-08, 1.100E-08,
1.300E-08, 1.100E-08, 9.700E-09, 9.170E-08, 1.700E-08, 4.200E-08,
1.900E-08, 1.800E-08, 1.600E-08, 6.200E-08, 1.900E-08, 5.800E-08,
1.500E-08, 3.000E-08, 1.400E-08, 3.100E-08, 2.800E-08, 2.400E-08,
2.500E-08, 2.500E-08, 2.700E-08, 2.200E-08, 1.900E-08, 2.400E-08,
2.400E-08, 3.400E-08, 1.600E-08, 2.000E-08, 2.500E-08, 1.400E-08,
1.800E-08, 2.200E-08, 1.400E-08, 1.900E-08, 1.800E-08, 2.200E-08,
3.100E-08, 1.700E-08, 1.200E-08)
######################################################################
# INPUT OF THEORY MODEL [MARCUCCI et al.]
######################################################################
# E is in MeV, S is in eV b; convert to MeV and MeV b, respectively
theory <- read.table("Marcucci2005.dat", header=FALSE)
interp.x <- theory[,1]
interp.y <- theory[,2] * 1e-6
# we will use JAGS interp.lin function to use this theoretical S-factor:
#
# - the columns of this table define vectors x and y
# - a single point is given by x_i, y_i
# - interp.lin gives the y value for the x value provided as argument e,
#   interp.lin(e, x, y)
######################################################################
# rjags ----->
######################################################################
cat('model {
###################
# LIKELIHOODS
###################
# systematic error as normalization factor y.norm...
for (i in 1:length(obsx1)) {
#
# S-FACTOR
# ...subject to extrinsic scatter:
obsy1[i] ~ dnorm(ya1[i], pow(yscat1, -2))
# ...subject to stat uncertainties:
ya1[i] ~ dnorm(ym1[i], pow(errobsy1[i], -2))
# ...subject to syst uncertainties:
ym1[i] <- y.norm1 * yt1[i]
# true S-factor [calculated from theory and then scaled]:
yt1[i] <- a.scale * interp.lin(obsx1[i], interp.x, interp.y)
}
for (i in 1:length(obsx2)) {
#
# S-FACTOR
# ...subject to extrinsic scatter:
obsy2[i] ~ dnorm(ya2[i], pow(yscat2, -2))
# ...subject to stat uncertainties:
ya2[i] ~ dnorm(ym2[i], pow(errobsy2[i], -2))
# ...subject to syst uncertainties:
ym2[i] <- y.norm2 * yt2[i]
# true S-factor [calculated from theory and then scaled]:
yt2[i] <- a.scale * interp.lin(obsx2[i], interp.x, interp.y)
}
for (i in 1:length(obsx3)) {
#
# S-FACTOR
# ...subject to extrinsic scatter:
obsy3[i] ~ dnorm(ya3[i], pow(yscat3, -2))
# ...subject to stat uncertainties:
ya3[i] ~ dnorm(ym3[i], pow(errobsy3[i], -2))
# ...subject to syst uncertainties:
ym3[i] <- y.norm3 * yt3[i]
# true S-factor [calculated from theory and then scaled]:
yt3[i] <- a.scale * interp.lin(obsx3[i], interp.x, interp.y)
}
for (i in 1:length(obsx4)) {
#
# S-FACTOR
# ...subject to extrinsic scatter:
obsy4[i] ~ dnorm(ya4[i], pow(yscat4, -2))
# ...subject to stat uncertainties:
ya4[i] ~ dnorm(ym4[i], pow(errobsy4[i], -2))
# ...subject to syst uncertainties:
ym4[i] <- y.norm4 * yt4[i]
# true S-factor [calculated from theory and then scaled]:
yt4[i] <- a.scale * interp.lin(obsx4[i], interp.x, interp.y)
}
###################
# PRIORS
###################
### scaling factor of theory [a.scale]
a.scale ~ dnorm(0.0, pow(10, -2))T(0,)        #  "a.scale" cannot become negative!
# extrinsic scatter in S-factor
# what happens to likelihood if yscat = 4e-6 ??
yscat1 ~ dnorm(0.0, pow(2e-6, -2))T(0,)       # sigma is 2e-6 MeVb
yscat2 ~ dnorm(0.0, pow(2e-6, -2))T(0,)
yscat3 ~ dnorm(0.0, pow(2e-6, -2))T(0,)
yscat4 ~ dnorm(0.0, pow(2e-6, -2))T(0,)
# systematic normalization factor for S-factor:
# log(): natural logarithm
y.norm1 ~ dlnorm(logmu1, pow(logsigma1, -2))
logmu1 <- log(1.0)      # median of factor uncertainty is 1.0
logsigma1 <- log(1.09)  # factor uncertainty is 1.09, i.e. 9% for MA97
y.norm2 ~ dlnorm(logmu2, pow(logsigma2, -2))
logmu2 <- log(1.0)      # median of factor uncertainty is 1.0
logsigma2 <- log(1.08)  # factor uncertainty is <1.08, i.e., <8% for BYS08
# we are using "8%", not "<8%"
y.norm3 ~ dlnorm(logmu3, pow(logsigma3, -2))
logmu3 <- log(1.0)      # median of factor uncertainty is 1.0
logsigma3 <- log(1.09)  # factor uncertainty is 1.09, i.e., 9% for SCH97
y.norm4 ~ dlnorm(logmu4, pow(logsigma4, -2))
logmu4 <- log(1.0)      # median of factor uncertainty is 1.0
logsigma4 <- log(1.045) # factor uncertainty is 1.045, i.e., 4.5% for CAS02
}', file={f <- tempfile()})
# dunif(min=0, max=1): gives uniform density
# pow(a,b) = a^b
######################################################################
# n.adapt:  number of iterations in the chain for adaptation
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# update(): performs the burn-in on each chain by running the MCMC for
#           n.burn iterations without saving any of the posterior samples
# coda.samples(): runs each MCMC chain for the number of iterations
#           specified by n.iter, but it does not save every iteration;
#           instead, it saves only ever nth iteration, where n is given
#           by thin
# n.chains: number of mcmc chains
n.chains <- 3
n.adapt  <- 5000
n.burn   <- 5000
n.iter   <- 10000
thin     <- 1
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model;
#
ourmodel <- jags.model(f, data = list(        ## jags wants all data in a list
'obsx1' = obsx1, 'obsy1' = obsy1, 'errobsy1' = errobsy1,
'obsx2' = obsx2, 'obsy2' = obsy2, 'errobsy2' = errobsy2,
'obsx3' = obsx3, 'obsy3' = obsy3, 'errobsy3' = errobsy3,
'obsx4' = obsx4, 'obsy4' = obsy4, 'errobsy4' = errobsy4,
'interp.x' = interp.x, 'interp.y' = interp.y
),
n.chains = n.chains, n.adapt = n.adapt)
update(ourmodel, n.burn)
# variable.names are variables to be recorded in output file of samples
mcmcChain <- coda.samples(ourmodel,
variable.names=c(
'a.scale',
'y.norm1', 'y.norm2', 'y.norm3', 'y.norm4',
'yscat1',  'yscat2',  'yscat3',  'yscat4'
),
n.iter=n.iter, thin=thin)
require(ggmcmc)
source("pair_wise_plot.R”)
require(ggmcmc)
source("pair_wise_plot.R”)
source("pair_wise_plot.R")
require(viridis)
require(viridisLite)
library(ggmcmc)
library(viridis)
library(viridisLite)
source("pair_wise_plot.R")
Sp <- ggs(as.mcmc(mcmcChain)[,c("a.scale", 'y.norm1', 'y.norm2', 'y.norm3', 'y.norm4',
'yscat1',  'yscat2',  'yscat3',  'yscat4')]) %>% as_tibble()
# Plot
pair_wise_plot(Sp)
mcmcChain
Sp <- ggs(mcmcChain[,c("a.scale", 'y.norm1', 'y.norm2', 'y.norm3', 'y.norm4',
'yscat1',  'yscat2',  'yscat3',  'yscat4')]) %>% as_tibble()
# Plot
pair_wise_plot(Sp)
library(ggridges)
pair_wise_plot(Sp)
