scat = scat)
samplerConst <- list(N = N,
Nre = Nre)
samplerInits <- list(y.norm = rep(1,Nre),
y.scat = rep(0.001,Nre),
e0_1 = 0.05, gb_1 = 0.6, ga_1 = 0.6,
e0_2 = 0.15, ga_2 = 0.6, gb_2 = 0.6,
e0_3 = 0.336, ga_3 = 0.6, gb_3 = 0.6,
e0_4 = 0.51, ga_4 = 0.6, gb_4 = 0.6,
e0_5 = 0.96, ga_5 = 0.6, gb_5 = 0.6,
e0_6 = 1.23, ga_6 = 0.6, gb_6 = 0.6,
e0_7 = 1.32, ga_7 = 0.6, gb_7 = 0.6,
ra = 4, rb = 4,mt=0
#                    ,k = 0.1
)
###############################################################
# (Alternative) If invoking Nimble MCMC stepwise (but more customisable)
##############################################################
ourmodel <- nimbleModel(code = samplerCode, constants = samplerConst,
data = samplerData, inits = samplerInits, check = FALSE
)
compileNimble(ourmodel)
# Always compile the model after you are done setting up with it
ourmodel$calculate()
# Calculate the log likelihood (logProb). If the value is not NA,
# we have successfully initialised the model (FULLY)
# One iteration: simulate -> new values -> calculate
conf <- configureMCMC(ourmodel,print=TRUE)
# print = TRUE tells you what kind of samplers are being used for each stochastic node
conf$addMonitors(c('e0_1','ga_1','gb_1','e0_2','ga_2','gb_2',
'e0_3', 'ga_3', 'gb_3', 'e0_4', 'ga_4', 'gb_4',
'e0_5', 'ga_5', 'gb_5', 'e0_6', 'ga_6', 'gb_6',
'e0_7', 'ga_7', 'gb_7',
'r_1', 'r_4', 'ra', 'rb',
'y.norm',
'y.scat'))
# Add the parameters to monitor throughout the MCMC process
samplerMCMC <- buildMCMC(conf)
# Note that if no configuration is required, we can directly jump towards buildMCMC.
# But you know, then theres no point in using this entire chunk of code
# where you can just run nimbleMCMC
compiledMCMC <- compileNimble(samplerMCMC,project = ourmodel,showCompilerOutput = TRUE)
# Complie the configured model again once we are done with configuring it;
# Just before we perform the MCMC runs
# Can include project = ourmodel; to include all the nimbleFunctions, nimbleModels that
# you would want to inherit the functions and models from
# resetFunctions = TRUE; if you would want to reset all the previously created functions
# in order to addd the new MCMC
n.chains = 1
n.iter = 3000
n.burnin = 1500
system.time(
mcmcChain <- runMCMC(compiledMCMC,niter = n.iter, nchain = n.chains, nburnin = n.burnin,
setSeed=9,samplesAsCodaMCMC = TRUE)
)
save(mcmcChain, file = "MCMCBe7.RData")
pdf("Final11.pdf")
plot(mcmcChain)
dev.off()
samp <- as.matrix(mcmcChain)
xx <- exp(seq(log(1e-8),log(2),length.out = 250))
# resonance 1
y1 <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp(xx[j],samp[,"e0_1"],samp [,"ga_1"],samp [,"gb_1"],
samp [,"ra"],
samp [,"rb"],jr = 2, la = 0, lb = 0),probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
y1 <- rbind(y1,mux)
}
gr1 <-  data.frame(x =xx, mean = y1[,"50%"],lwr1=y1[,"16%"],lwr2=y1[,"2.5%"],lwr3=y1[,"0.15%"],
upr1=y1[,"84%"],
upr2=y1[,"97.5%"],upr3=y1[,"99.85%"])
# resonance 2
y2 <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp(xx[j],samp[,"e0_2"],samp[,"ga_2"],samp [,"gb_2"],
samp[,"ra"],
samp[,"rb"],jr = 3, la = 1, lb = 1),
probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
y2 <- rbind(y2,mux)
}
gr2 <-  data.frame(x =xx, mean = y2[,"50%"],lwr1=y2[,"16%"],lwr2=y2[,"2.5%"],lwr3=y2[,"0.15%"],
upr1=y2[,"84%"],
upr2=y2[,"97.5%"],upr3=y2[,"99.85%"])
# resonance 3
y3 <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp(xx[j],samp[,"e0_3"],samp[,"ga_3"],samp [,"gb_3"],
samp[,"ra"],
samp[,"rb"],jr = 3, la = 1, lb = 1),
probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
y3 <- rbind(y3,mux)
}
gr3 <-  data.frame(x =xx, mean = y3[,"50%"],lwr1=y3[,"16%"],lwr2=y3[,"2.5%"],lwr3=y3[,"0.15%"],
upr1=y3[,"84%"],
upr2=y3[,"97.5%"],upr3=y3[,"99.85%"])
# resonance 4
y4 <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp(xx[j],samp[,"e0_4"],samp[,"ga_4"],samp [,"gb_4"],
samp[,"ra"],
samp[,"rb"],jr = 1, la = 0, lb = 0),
probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
y4 <- rbind(y4,mux)
}
gr4 <-  data.frame(x =xx, mean = y4[,"50%"],lwr1=y4[,"16%"],lwr2=y4[,"2.5%"],lwr3=y4[,"0.15%"],
upr1=y4[,"84%"],
upr2=y4[,"97.5%"],upr3=y4[,"99.85%"])
# resonance 5
y5 <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp(xx[j],samp[,"e0_5"],samp[,"ga_5"],samp [,"gb_5"],
samp[,"ra"],
samp[,"rb"],jr = 4, la = 3, lb = 3),
probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
y5 <- rbind(y5,mux)
}
gr5 <-  data.frame(x =xx, mean = y5[,"50%"],lwr1=y5[,"16%"],lwr2=y5[,"2.5%"],lwr3=y5[,"0.15%"],
upr1=y5[,"84%"],
upr2=y5[,"97.5%"],upr3=y5[,"99.85%"])
# resonance 6
y6 <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp(xx[j],samp[,"e0_6"],samp[,"ga_6"],samp [,"gb_6"],
samp[,"ra"],
samp[,"rb"],jr = 2, la = 1, lb = 1),
probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
y6  <- rbind(y6,mux)
}
gr6 <-  data.frame(x =xx, mean = y6[,"50%"],lwr1=y6[,"16%"],lwr2=y6[,"2.5%"],lwr3=y6[,"0.15%"],
upr1=y6[,"84%"],
upr2=y6[,"97.5%"],upr3=y6[,"99.85%"])
yall <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp7mod(xx[j],samp[,"e0_1"],samp[,"ga_1"],samp [,"gb_1"],
samp[,"ra"],samp[,"rb"],
samp[,"e0_2"],samp[,"ga_2"],samp [,"gb_2"],
samp[,"ra"],samp[,"rb"],
samp[,"e0_3"],samp[,"ga_3"],samp [,"gb_3"],
samp[,"ra"],samp[,"rb"],
samp[,"e0_4"],samp[,"ga_4"],samp [,"gb_4"],
samp[,"ra"],samp[,"rb"],
samp[,"e0_5"],samp[,"ga_5"],samp [,"gb_5"],
samp[,"ra"],samp[,"rb"],
samp[,"e0_6"],samp[,"ga_6"],samp [,"gb_6"],
samp[,"ra"],samp[,"rb"],
samp[,"e0_7"],samp[,"ga_7"],samp [,"gb_7"],
samp[,"ra"],samp[,"rb"]),
probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
yall <- rbind(yall,mux)
}
grall <-  data.frame(x =xx, mean = yall[,"50%"],lwr1=yall[,"16%"],lwr2=yall[,"2.5%"],lwr3=yall[,"0.15%"],
upr1=yall[,"84%"],
upr2=yall[,"97.5%"],upr3=yall[,"99.85%"])
### plot Maxwell-Boltzmann "factor" at T=1 GK [arbitrary scale]
#for ( i in round(runif(500, min=1, max=nsamp)) ) {
#  lines(x1, 3e2*(x1*(2.718^(-x1/(0.086173*0.5)))))
#}
# Plot all
ggplot(Be7np,aes(x=E,y=S))+
geom_ribbon(data=gr1,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("darkolivegreen4"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=gr1,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("darkolivegreen4"),alpha=0.8,show.legend=FALSE) +
geom_ribbon(data=gr2,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("#9e9ac8"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=gr2,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("#984ea3"),alpha=0.8,show.legend=FALSE) +
geom_ribbon(data=gr3,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("darkgoldenrod2"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=gr3,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("darkgoldenrod2"),alpha=0.8,show.legend=FALSE) +
geom_ribbon(data=gr4,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("cyan3"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=gr4,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("cyan3"),alpha=0.8,show.legend=FALSE) +
geom_ribbon(data=gr5,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("chocolate1"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=gr5,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("chocolate1"),alpha=0.8,show.legend=FALSE) +
geom_ribbon(data=gr6,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("orange"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=gr6,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("orange"),alpha=0.8,show.legend=FALSE) +
geom_ribbon(data=grall,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("red3"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=grall,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("red3"),alpha=0.8,show.legend=FALSE) +
geom_point(data=Be7np,aes(x=obsx,y=obsy,group=dat,color=dat,shape=type),size=2.75,alpha=0.75)+
geom_errorbar(show.legend = FALSE,aes(x=E,y=S,ymin=S-Stat,ymax=S+Stat,group=dat,color=dat),width=0.025)+
scale_shape_stata(name="Dataset")+
scale_color_stata(name="Dataset")+
scale_x_log10() +
#scale_y_log10() +
theme_bw() + ylab(expression(paste(sqrt(E), sigma, " (", sqrt(MeV), "b)"))) +
xlab("Energy (MeV)") +
theme(legend.position = "top",
legend.background = element_rect(colour = "white", fill = "white"),
plot.background = element_rect(colour = "white", fill = "white"),
panel.background = element_rect(colour = "white", fill = "white"),
legend.key = element_rect(colour = "white", fill = "white"),
axis.title = element_text(color="#666666", size=15),
axis.text  = element_text(size=12),
strip.text = element_text(size=10),
strip.background = element_rect("gray85")) +
coord_cartesian(xlim=c(1e-8,1),ylim=c(0,10))
data(Be7np)
re <- as.numeric(as.factor(Be7np$dat))
Nre <- length(unique(Be7np$dat))
# Unique removes duplicated vector, we want to know how many groups of
# data are there
N <- nrow(Be7np) # Total No of data sets
obsy <- Be7np$S    # Response variable in MeV
obsx <-  Be7np$E   # Predictors
erry <- Be7np$Stat # Error in MeV
set <- Be7np$dat # Get the labels as a vector
fu <- log(c(1.085,2.25,1.10,2.25,1.050,1.051,2.25,1.020,1.051,1.032))
scat <- c(1e-6,2,1e-6,2,1e-6,1e-6,2,1e-6,2,1e-6)
samplerCode <- nimbleCode({
###################
# LIKELIHOODS
###################
# - careful: dnorm is differently defined in R and JAGS!
# - precision=sigma^(-2)
# - in a for loop, make sure **all** variables on the LEFT of an
#   expression has the index [i]
# - systematic error as normalization factor y.norm...
## Calling sigmaBe7mod once!
sigmaBe7modT[1:N] <- sigmaBe7mod(obsx[1:N],
e0_1, ga_1, gb_1, ra, rb,
e0_2, ga_2, gb_2, ra, rb,
e0_3, ga_3, gb_3, ra, rb,
e0_4, ga_4, gb_4, ra, rb,
e0_5, ga_5, gb_5, ra, rb,
e0_6, ga_6, gb_6, ra, rb,
e0_7, ga_7, gb_7, ra, rb)
for (i in 1:N){
obsy[i] ~ dnorm(ym[i], sd = erry[i])
ym[i] ~ dnorm(yt[i],sd = y.scat[re[i]])
yt[i] <- y.norm[re[i]]*sqrt(obsx[i])*sigmaBe7modT[i]
}
###################
# PRIORS
###################
# parameters: ecm, e0, ga, gb, ra, rb, xj, xla, xlb
# channel radii
ra ~ T(dnorm(4.0, pow(0.5, -2)),0,Inf)
rb ~ T(dnorm(4.0, pow(0.5, -2)),0,Inf)
# Wigner limit: wl = hbar^2/(m_red a_c^2) = 41.80159/(M_red a_c^2)
#
# neutron channel: wl_n = 41.80159/(0.88186 a_c^2) = 47.40160/a_c^2
# proton channel:  wl_p = 41.80159/(0.88079 a_c^2) = 47.45920/a_c^2
#
wl_n <- 47.40160*pow(ra, -2)
wl_p <- 47.45920*pow(rb, -2)
###################################################################
# RESONANCE 1: e0=0 MeV
# resonance spin, orbital angular momenta   # 2-
# energy eigenvalue
e0_1 ~ T(dnorm(0.0, pow(0.1, -2)),0,Inf)
# reduced widths
ga_1 ~ T(dnorm(0.0, pow(wl_n/2, -2)),0,Inf)
gb_1 ~ T(dnorm(0.0, pow(wl_p/2, -2)),0,Inf)
##############
# RESONANCE 2: e0=0.150 MeV
# resonance spin, orbital angular momenta # 3+
# energy eigenvalue
e0_2 ~ T(dnorm(0.15, pow(0.025, -2)),0,Inf)         # positive since we see sigma peak
# reduced widths
ga_2 ~ T(dnorm(0.0, pow(wl_n/2, -2)),0,Inf)
gb_2 ~ T(dnorm(0.0, pow(wl_p/2, -2)),0,Inf)
##############
# RESONANCE 3: e0=0.336 MeV
# resonance spin, orbital angular momenta  # 3+
# energy eigenvalue
e0_3 ~ T(dnorm(0.336, pow(0.010, -2)),0,Inf)         # positive since we see sigma peak
# reduced widths
ga_3 ~ T(dnorm(0.0, pow(wl_n/2, -2)),0,Inf)
gb_3 ~ T(dnorm(0.0, pow(wl_p/2, -2)),0,Inf)
##############
# RESONANCE 4: e0=0.510 MeV
# resonance spin, orbital angular momenta # 1-
# energy eigenvalue
e0_4 ~ T(dnorm(0.51, pow(0.1, -2)),0,Inf)         # positive since we see sigma peak
# reduced widths
ga_4 ~ T(dnorm(0.0, pow(wl_n/2, -2)),0,Inf)
gb_4 ~ T(dnorm(0.0, pow(wl_p/2, -2)),0,Inf)
##############
# RESONANCE 5: e0=0.960 MeV
# resonance spin, orbital angular momenta # 4+
# energy eigenvalue
e0_5 ~ T(dnorm(0.96, pow(0.1, -2)),0,Inf)         # positive since we see sigma peak
# reduced widths
ga_5 ~ T(dnorm(0.0, pow(wl_n/2, -2)),0,Inf)
gb_5 ~ T(dnorm(0.0, pow(wl_p/2, -2)),0,Inf)
##############
# RESONANCE 6: e0=1.23 MeV
# resonance spin, orbital angular momenta # 2+
# energy eigenvalue
e0_6 ~ T(dnorm(1.23, pow(0.1, -2)),0,Inf)         # positive since we see sigma peak
# reduced widths
ga_6 ~ T(dnorm(0.0, pow(wl_n/2, -2)),0,Inf)
gb_6 ~ T(dnorm(0.0, pow(wl_p/2, -2)),0,Inf)
##############
# RESONANCE 7: e0 = 1.32 MeV
# resonance spin, orbital angular momenta # 0+
# energy eigenvalue
e0_7 ~ T(dnorm(1.32, pow(0.1, -2)),0,Inf)         # positive since we see sigma peak
# reduced widths
ga_7 ~ T(dnorm(0.0, pow(wl_n/2, -2)),0,Inf)
gb_7 ~ T(dnorm(0.0, pow(wl_p/2, -2)),0,Inf)
##################################################################
for (k in 1:Nre) {
# Systematic Uncertainty as a highly informative prior
y.norm[k] ~ dlnorm(log(1.0), pow(fu[k], -2))
y.scat[k] ~ T(dnorm(0,sd=scat[k]),0,Inf)
}
#  k ~ T(dnorm(0,sd=0.15),0,Inf)
r_1 <- ga_1/gb_1
r_4 <- ga_4/gb_4
})
samplerData <- list(obsy = obsy,
re = re, # Sample size
erry = erry,
obsx = obsx,
fu = fu,
scat = scat)
samplerConst <- list(N = N,
Nre = Nre)
samplerInits <- list(y.norm = rep(1,Nre),
y.scat = rep(0.001,Nre),
e0_1 = 0.05, gb_1 = 0.6, ga_1 = 0.6,
e0_2 = 0.15, ga_2 = 0.6, gb_2 = 0.6,
e0_3 = 0.336, ga_3 = 0.6, gb_3 = 0.6,
e0_4 = 0.51, ga_4 = 0.6, gb_4 = 0.6,
e0_5 = 0.96, ga_5 = 0.6, gb_5 = 0.6,
e0_6 = 1.23, ga_6 = 0.6, gb_6 = 0.6,
e0_7 = 1.32, ga_7 = 0.6, gb_7 = 0.6,
ra = 4, rb = 4,mt=0
#                    ,k = 0.1
)
###############################################################
# (Alternative) If invoking Nimble MCMC stepwise (but more customisable)
##############################################################
ourmodel <- nimbleModel(code = samplerCode, constants = samplerConst,
data = samplerData, inits = samplerInits, check = FALSE
)
compileNimble(ourmodel)
# Always compile the model after you are done setting up with it
ourmodel$calculate()
# Calculate the log likelihood (logProb). If the value is not NA,
# we have successfully initialised the model (FULLY)
# One iteration: simulate -> new values -> calculate
conf <- configureMCMC(ourmodel,print=TRUE)
# print = TRUE tells you what kind of samplers are being used for each stochastic node
conf$addMonitors(c('e0_1','ga_1','gb_1','e0_2','ga_2','gb_2',
'e0_3', 'ga_3', 'gb_3', 'e0_4', 'ga_4', 'gb_4',
'e0_5', 'ga_5', 'gb_5', 'e0_6', 'ga_6', 'gb_6',
'e0_7', 'ga_7', 'gb_7',
'r_1', 'r_4', 'ra', 'rb',
'y.norm',
'y.scat'))
# Add the parameters to monitor throughout the MCMC process
samplerMCMC <- buildMCMC(conf)
# Note that if no configuration is required, we can directly jump towards buildMCMC.
# But you know, then theres no point in using this entire chunk of code
# where you can just run nimbleMCMC
compiledMCMC <- compileNimble(samplerMCMC,project = ourmodel,showCompilerOutput = TRUE)
# Complie the configured model again once we are done with configuring it;
# Just before we perform the MCMC runs
# Can include project = ourmodel; to include all the nimbleFunctions, nimbleModels that
# you would want to inherit the functions and models from
# resetFunctions = TRUE; if you would want to reset all the previously created functions
# in order to addd the new MCMC
n.chains = 1
n.iter = 6000
n.burnin = 2500
system.time(
mcmcChain <- runMCMC(compiledMCMC,niter = n.iter, nchain = n.chains, nburnin = n.burnin,
setSeed=9,samplesAsCodaMCMC = TRUE)
)
save(mcmcChain, file = "MCMCBe7.RData")
pdf("Final11.pdf")
plot(mcmcChain)
dev.off()
samp <- as.matrix(mcmcChain)
xx <- exp(seq(log(1e-8),log(2),length.out = 250))
# resonance 1
y1 <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp(xx[j],samp[,"e0_1"],samp [,"ga_1"],samp [,"gb_1"],
samp [,"ra"],
samp [,"rb"],jr = 2, la = 0, lb = 0),probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
y1 <- rbind(y1,mux)
}
gr1 <-  data.frame(x =xx, mean = y1[,"50%"],lwr1=y1[,"16%"],lwr2=y1[,"2.5%"],lwr3=y1[,"0.15%"],
upr1=y1[,"84%"],
upr2=y1[,"97.5%"],upr3=y1[,"99.85%"])
# resonance 2
y2 <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp(xx[j],samp[,"e0_2"],samp[,"ga_2"],samp [,"gb_2"],
samp[,"ra"],
samp[,"rb"],jr = 3, la = 1, lb = 1),
probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
y2 <- rbind(y2,mux)
}
gr2 <-  data.frame(x =xx, mean = y2[,"50%"],lwr1=y2[,"16%"],lwr2=y2[,"2.5%"],lwr3=y2[,"0.15%"],
upr1=y2[,"84%"],
upr2=y2[,"97.5%"],upr3=y2[,"99.85%"])
# resonance 3
y3 <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp(xx[j],samp[,"e0_3"],samp[,"ga_3"],samp [,"gb_3"],
samp[,"ra"],
samp[,"rb"],jr = 3, la = 1, lb = 1),
probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
y3 <- rbind(y3,mux)
}
gr3 <-  data.frame(x =xx, mean = y3[,"50%"],lwr1=y3[,"16%"],lwr2=y3[,"2.5%"],lwr3=y3[,"0.15%"],
upr1=y3[,"84%"],
upr2=y3[,"97.5%"],upr3=y3[,"99.85%"])
# resonance 4
y4 <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp(xx[j],samp[,"e0_4"],samp[,"ga_4"],samp [,"gb_4"],
samp[,"ra"],
samp[,"rb"],jr = 1, la = 0, lb = 0),
probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
y4 <- rbind(y4,mux)
}
gr4 <-  data.frame(x =xx, mean = y4[,"50%"],lwr1=y4[,"16%"],lwr2=y4[,"2.5%"],lwr3=y4[,"0.15%"],
upr1=y4[,"84%"],
upr2=y4[,"97.5%"],upr3=y4[,"99.85%"])
# resonance 5
y5 <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp(xx[j],samp[,"e0_5"],samp[,"ga_5"],samp [,"gb_5"],
samp[,"ra"],
samp[,"rb"],jr = 4, la = 3, lb = 3),
probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
y5 <- rbind(y5,mux)
}
gr5 <-  data.frame(x =xx, mean = y5[,"50%"],lwr1=y5[,"16%"],lwr2=y5[,"2.5%"],lwr3=y5[,"0.15%"],
upr1=y5[,"84%"],
upr2=y5[,"97.5%"],upr3=y5[,"99.85%"])
# resonance 6
y6 <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp(xx[j],samp[,"e0_6"],samp[,"ga_6"],samp [,"gb_6"],
samp[,"ra"],
samp[,"rb"],jr = 2, la = 1, lb = 1),
probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
y6  <- rbind(y6,mux)
}
gr6 <-  data.frame(x =xx, mean = y6[,"50%"],lwr1=y6[,"16%"],lwr2=y6[,"2.5%"],lwr3=y6[,"0.15%"],
upr1=y6[,"84%"],
upr2=y6[,"97.5%"],upr3=y6[,"99.85%"])
yall <- NULL
for(j in 1:length(xx)){
mux <-  quantile(sqrt(xx[j])*sigma7Benp7mod(xx[j],samp[,"e0_1"],samp[,"ga_1"],samp [,"gb_1"],
samp[,"ra"],samp[,"rb"],
samp[,"e0_2"],samp[,"ga_2"],samp [,"gb_2"],
samp[,"ra"],samp[,"rb"],
samp[,"e0_3"],samp[,"ga_3"],samp [,"gb_3"],
samp[,"ra"],samp[,"rb"],
samp[,"e0_4"],samp[,"ga_4"],samp [,"gb_4"],
samp[,"ra"],samp[,"rb"],
samp[,"e0_5"],samp[,"ga_5"],samp [,"gb_5"],
samp[,"ra"],samp[,"rb"],
samp[,"e0_6"],samp[,"ga_6"],samp [,"gb_6"],
samp[,"ra"],samp[,"rb"],
samp[,"e0_7"],samp[,"ga_7"],samp [,"gb_7"],
samp[,"ra"],samp[,"rb"]),
probs=c(0.0015,0.025, 0.16, 0.5, 0.84, 0.975,0.9985))
yall <- rbind(yall,mux)
}
grall <-  data.frame(x =xx, mean = yall[,"50%"],lwr1=yall[,"16%"],lwr2=yall[,"2.5%"],lwr3=yall[,"0.15%"],
upr1=yall[,"84%"],
upr2=yall[,"97.5%"],upr3=yall[,"99.85%"])
### plot Maxwell-Boltzmann "factor" at T=1 GK [arbitrary scale]
#for ( i in round(runif(500, min=1, max=nsamp)) ) {
#  lines(x1, 3e2*(x1*(2.718^(-x1/(0.086173*0.5)))))
#}
# Plot all
ggplot(Be7np,aes(x=E,y=S))+
geom_ribbon(data=gr1,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("darkolivegreen4"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=gr1,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("darkolivegreen4"),alpha=0.8,show.legend=FALSE) +
geom_ribbon(data=gr2,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("#9e9ac8"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=gr2,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("#984ea3"),alpha=0.8,show.legend=FALSE) +
geom_ribbon(data=gr3,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("darkgoldenrod2"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=gr3,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("darkgoldenrod2"),alpha=0.8,show.legend=FALSE) +
geom_ribbon(data=gr4,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("cyan3"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=gr4,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("cyan3"),alpha=0.8,show.legend=FALSE) +
geom_ribbon(data=gr5,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("chocolate1"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=gr5,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("chocolate1"),alpha=0.8,show.legend=FALSE) +
geom_ribbon(data=gr6,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("orange"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=gr6,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("orange"),alpha=0.8,show.legend=FALSE) +
geom_ribbon(data=grall,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("red3"),alpha=0.4,show.legend=FALSE) +
geom_ribbon(data=grall,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("red3"),alpha=0.8,show.legend=FALSE) +
geom_point(data=Be7np,aes(x=obsx,y=obsy,group=dat,color=dat,shape=type),size=2.75,alpha=0.75)+
geom_errorbar(show.legend = FALSE,aes(x=E,y=S,ymin=S-Stat,ymax=S+Stat,group=dat,color=dat),width=0.025)+
scale_shape_stata(name="Dataset")+
scale_color_stata(name="Dataset")+
scale_x_log10() +
#scale_y_log10() +
theme_bw() + ylab(expression(paste(sqrt(E), sigma, " (", sqrt(MeV), "b)"))) +
xlab("Energy (MeV)") +
theme(legend.position = "top",
legend.background = element_rect(colour = "white", fill = "white"),
plot.background = element_rect(colour = "white", fill = "white"),
panel.background = element_rect(colour = "white", fill = "white"),
legend.key = element_rect(colour = "white", fill = "white"),
axis.title = element_text(color="#666666", size=15),
axis.text  = element_text(size=12),
strip.text = element_text(size=10),
strip.background = element_rect("gray85")) +
coord_cartesian(xlim=c(1e-8,1),ylim=c(0,10))
scat
scat
mcmcChain
gr1
gr1
gr2
re
scat[re]
