ABC_Wegmann <-ABC_mcmc(method="Wegmann", model=toy_model, prior=toy_prior,
summary_stat_target=sum_stat_obs, n_rec=n, n_calibration=n_calib,
tolerance_quantile=tol_quant, use_seed=TRUE)
hist(ABC_Wegmann$param[,1])
ABC_Wegmann
sum_stat_obs
toy_model
n=1e4
tol_quant=0.2
ABC_Wegmann <- ABC_mcmc(method="Marjoram", model=toy_model, prior=toy_prior,
summary_stat_target=sum_stat_obs, n_rec=n,
tolerance_quantile=tol_quant, use_seed=TRUE)
ABC_Wegmann
n=1e4
ABC_sim<-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n, use_seed=TRUE)
n=1e4
tol = 0.25
ABC_sim<-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n, summary_stat_target=sum_stat_obs,tol=tol,
use_seed=TRUE)
ABC_sim
hist(ABC_sim$param[,1])
n=1e4
tol = 0.2
ABC_sim<-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n, summary_stat_target=sum_stat_obs,tol=tol,
use_seed=TRUE)
hist(ABC_sim$param[,1])
n=1e4
tol = 0.1
ABC_sim<-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n, summary_stat_target=sum_stat_obs,tol=tol,
use_seed=TRUE)
hist(ABC_sim$param[,1])
dim(ABC_sim$param)
n=1e4
tol = 0.01
ABC_sim<-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n, summary_stat_target=sum_stat_obs,tol=tol,
use_seed=TRUE)
hist(ABC_sim$param[,1])
n=1e4
tol = 0.001
ABC_sim<-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n, summary_stat_target=sum_stat_obs,tol=tol,
use_seed=TRUE)
hist(ABC_sim$param[,1])
n=5e4
tol = 0.001
ABC_sim<-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n, summary_stat_target=sum_stat_obs,tol=tol,
use_seed=TRUE)
hist(ABC_sim$param[,1])
library(coda)
# assuming the data are 10 samples of a normal distribution
# with mean 5.3 and sd 2.7
data =  rnorm(10, mean =5.3, sd = 2.7)
# we want to use ABC to infer the parameters that were used.
# we sample from the same model and use mean and variance
# as summary statstitics. We return true for ABC acceptance when
# the difference to the data is smaller than a certain threshold
meandata <- mean(data)
standarddeviationdata <- sd(data)
ABC_acceptance <- function(par){
# prior to avoid negative standard deviation
if (par[2] <= 0) return(F)
# stochastic model generates a sample for given par
samples <- rnorm(10, mean = par[1], sd = par[2])
# comparison with the observed summary statistics
diffmean <- abs(mean(samples) - meandata)
diffsd <- abs(sd(samples) - standarddeviationdata)
if((diffmean < 0.1) & (diffsd < 0.2)) return(T) else return(F)
}
# we plug this in in a standard metropolis hastings MCMC,
# with the metropolis acceptance exchanged for the ABC acceptance
run_MCMC_ABC <- function(startvalue, iterations){
chain = array(dim = c(iterations+1,2))
chain[1,] = startvalue
for (i in 1:iterations){
# proposalfunction
proposal = rnorm(2,mean = chain[i,], sd= c(0.7,0.7))
if(ABC_acceptance(proposal)){
chain[i+1,] = proposal
}else{
chain[i+1,] = chain[i,]
}
}
return(mcmc(chain))
}
posterior <- run_MCMC_ABC(c(4,2.3),300000)
plot(posterior)
log(100)
toy_prior <- list(c("lognormal",log(100),log(100)),c("lognormal",log(100),log(100)),
c("lognormal",log(100),log(100)),log(100),log(100))
# Fraction of acceptable data, measured via Euclidian distance between simulation and obs_data
tolerance=c(1,0.75,0.5,0.25,0.15)
n=5e4
tol = 0.001
ABC_sim<-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n, summary_stat_target=sum_stat_obs,tol=tol,
use_seed=TRUE)
hist(ABC_sim$param[,1])
toy_prior <- list(c("lognormal",log(100),log(100)),c("lognormal",log(100),log(100)),
c("lognormal",log(100),log(100)),c("lognormal",log(100),log(100)))
# Fraction of acceptable data, measured via Euclidian distance between simulation and obs_data
tolerance=c(1,0.75,0.5,0.25,0.15)
n=5e4
tol = 0.001
ABC_sim<-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n, summary_stat_target=sum_stat_obs,tol=tol,
use_seed=TRUE)
hist(ABC_sim$param[,1])
n=5e4
tol = 0.01
ABC_sim<-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n, summary_stat_target=sum_stat_obs,tol=tol,
use_seed=TRUE)
hist(ABC_sim$param[,1])
ABC_sim$param
pdat <- as.data.frame(ABC_sim$param)
ggplot(data = pdat,aes(x = V1,y = V2)) +
geom_density_2d()
ggplot(data = pdat,aes(x = V1,y = V2)) +
geom_point()
n=1e5
tol = 0.1
ABC_sim<-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n, summary_stat_target=sum_stat_obs,tol=tol,
use_seed=TRUE)
range(rlnorm(log(100),log(100)))
range(rlnorm(log(100),log(100)))
range(rlnorm(1e5,log(100),log(100)))
range(rlnorm(1e5,log(100),log(10)))
range(rlnorm(1e5,log(10),log(10)))
range(rlnorm(1e5,log(10),log(1)))
range(rlnorm(1e5,log(10),log(10)))
range(rlnorm(1e5,log(10),log(5)))
range(rlnorm(1e5,log(10),log(2)))
range(rlnorm(1e5,log(10),log(3)))
range(rlnorm(1e5,log(10),log(2.5)))
range(rlnorm(1e5,log(1),log(2.5)))
toy_prior <- list(c("lognormal",log(2.5),log(2.5)),c("lognormal",log(2.5),log(2.5)),
c("lognormal",log(2.5),log(2.5)),c("lognormal",log(2.5),log(2.5)))
# Fraction of acceptable data, measured via Euclidian distance between simulation and obs_data
tolerance=c(1,0.75,0.5,0.25,0.15)
n=1e5
tol = 0.1
ABC_sim<-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n, summary_stat_target=sum_stat_obs,tol=tol,
use_seed=TRUE)
hist(ABC_sim$param[,1])
pdat <- as.data.frame(ABC_sim$param)
ggplot(data = pdat,aes(x = V1,y = V2)) +
geom_point()
ggplot(data = pdat,aes(x = V1,y = V3)) +
geom_point()
hist(ABC_sim$param[,1])
mean(ABC_sim$param[,1])
median(ABC_sim$param[,1])
median(ABC_sim$param[10:,1])
median(ABC_sim$param[1:10,1])
ABC_sim
toy_model <- cmpfun(toy_model)
require(compiler)
toy_model <- cmpfun(toy_model)
x1 = 34
x2 = 12
x3 = 456
x4 = 78
obs_data <- toy_model(c(x1,x2,x3,x4))
# Summary, just the data - no compression
sum_stat_obs <- obs_data
toy_prior <- list(c("lognormal",log(2.5),log(2.5)),c("lognormal",log(2.5),log(2.5)),
c("lognormal",log(2.5),log(2.5)),c("lognormal",log(2.5),log(2.5)))
# Fraction of acceptable data, measured via Euclidian distance between simulation and obs_data
tolerance=c(1,0.75,0.5,0.25,0.15)
n=1e5
tol = 0.1
ABC_sim<-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n, summary_stat_target=sum_stat_obs,tol=tol,
use_seed=TRUE)
hist(ABC_sim$param[,1])
hist(ABC_sim$param[,2])
hist(ABC_sim$param[,3])
hist(ABC_sim$param[,4])
#S1 <- mean(c(val1,val2,val3,val4))
#S2 <- sd(c(val1,val2,val3,val4))
return(c(log(val1),log(val2),log(val3),log(val4),log(val5)))
toy_model(c(x1,x2,x3,x4))
toy_model <- function(par){
val1 <- 1e-1*par[1]^4 +
2e-1*par[2]^3.0 +
7e-1*par[3]^2 +
4e-1*par[4];
val2 <- 3e-2*par[1]^4.0 +
5e-2*par[2]^3.0 +
9e-2*par[3]^2.0 +
1e-2*par[4];
val3 <- 7e-3*par[1]^4.0 +
1e-3*par[2]^3.0 +
4e-3*par[3]^2 +
2e-3*par[4];
val4 <- 2e-4*par[1]^4 +
5e-4*par[2]^3 +
8e-4*par[3]^2 +
8e-4*par[4]
val5 <- 9e-5*par[1]^4 +
6e-5*par[2]^3 +
3e-5*par[3]^2 +
1e-5*par[4]
#S1 <- mean(c(val1,val2,val3,val4))
#S2 <- sd(c(val1,val2,val3,val4))
return(c(val1,val2,val3,val4,val5))
}
toy_model <- cmpfun(toy_model)
# Observed data
x1 = 34
x2 = 12
x3 = 456
x4 = 78
obs_data <- toy_model(c(x1,x2,x3,x4))
obs_data
logit(34)
require(gtools)
logit(34)
inv.logit(34)
inv.logit(34)
inv.logit(90)
log(1003)
log(1004)
log(1004,10)
log(1003,10)
log(1003,100)
log(1004,100)
log(1004,1)
log(1003,1)
log(1003,2)
log(1004,2)
log(1004,1e4)
log(1003,1e4)
log(1003,0.2)
log(1004,0.2)
log(1004,1e-2)
log(1007,1e-2)
log(1010,1e-2)
log(32,1e-2)
log(12,1e-2)
log(500,1e-2)
log(500,10)
library(sparklyr)
options(sparklyr.java9 = TRUE)
sc <- spark_connect(master = "local")
iris_tbl <- sdf_copy_to(sc, iris, name = "iris_tbl")
media_petal <- iris_div %>%
group_by(Species) %>%
summarise(media = mean(Petal_Length))
sdf_num_partitions(iris_tbl)
iris_div <- sdf_repartition(iris_tbl, partitions = 3)
sdf_num_partitions(iris_div)
library(sparklyr)
spark_available_versions()
library(nuclear)
data("dpg")
header(dpg)
head(dpg)
library(microbenchmark)
res <- microbenchmark(sfactorHe3dpNimble(obsx,0.35,1,0.02,6,5,0),
sfactorHe3dpc(obsx,0.35,1,0.02,6,5,0),
sfactorHe3dp(obsx,0.35,1,0.02,6,5,0),times=1000L)
# 3Hedp analysis
#
# purpose: Real  DATA
#
# - 5 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorHe3dp(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
######################################################################
# preparation: remove all variables from the work space
#rm(list=ls())
set.seed(123)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(gsl);library(latex2exp)
require(nimble)
######################################################################
## ARTIFICIAL DATA GENERATION
data("He3dp")
re <- as.numeric(as.factor(He3dp$dat))
Nre <- length(unique(He3dp$dat))
ik <- as.numeric(as.factor(He3dp$Kinematics))
Nik <- length(unique(He3dp$Kinematics))
N <- nrow(He3dp)
obsy <- He3dp$S    # Response variable
obsx <-  He3dp$E   # Predictors
erry <- He3dp$Stat
set <- as.factor(He3dp$dat)
lab <- He3dp$Kinematics
syst <- as.numeric(unlist(exp(aggregate(He3dp$Syst, by=list(He3dp$dat), FUN=mean)[2])))
M <- 500
xx <- seq(min(obsx),max(obsx),length.out = M)
model.data <- list(obsy = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
syst = syst,
xx = xx
)
samplerConst <- list(N = N, # Sample size
M = M,
Nre = Nre,
re = re, # This is used to "iterate"
Nik = Nik,
ik  = ik
)
library(compiler)
sfactorHe3dpc <- cmpfun(sfactorHe3dp)
sfactorHe3dpNimble <- nimbleRcall(function(ecm = double(0),
e0 = double(0),gi = double(0),
gf = double(0),ri = double(0),
rf = double(0),ue = double(0)){},
Rfun = 'sfactorHe3dpc',
returnType = double(0))
library(microbenchmark)
res <- microbenchmark(sfactorHe3dpNimble(obsx,0.35,1,0.02,6,5,0),
sfactorHe3dpc(obsx,0.35,1,0.02,6,5,0),
sfactorHe3dp(obsx,0.35,1,0.02,6,5,0),times=1000L)
res
require(dplyr)
mollusc <- function(n_s = 1000, n_t = 4000,
alpha = 80, beta = 40, phi = 55, mu = 30, Omega = 10, s_min = -270, s_max = 62,
A = 25, a = 12, b = 16, P = 2, W_1 = 1, W_2 = 1, N = 0, L = 0, D = 1,
theta_start = 0, theta_end = 10*pi) {
alpha <- alpha * pi / 180
beta <- beta * pi / 180
phi <- phi * pi / 180
mu <- mu * pi / 180
Omega <- Omega * pi / 180
s_min <- s_min * pi / 180
s_max <- s_max * pi / 180
P <- P * pi / 180
W_1 <- W_1 * pi / 180
W_2 <- W_2 * pi / 180
data.frame(expand.grid(seq(s_min, s_max, (s_max-s_min)/(n_s-1)),
seq(theta_start, theta_end, (theta_end-theta_start)/(n_t-1))) %>%
dplyr::rename(s = Var1, theta = Var2)) %>%
dplyr::mutate(
f_theta = ifelse(N == 0, Inf, 360/N*(theta*N/360-round(theta*N/360, 0))),
R_e = (a^(-2)*(cos(s))^2+b^(-2)*(sin(s))^2)^(-0.5),
k = L*exp(-(2*(s-P)/W_1)^2)*exp(-(2*f_theta/W_2)^2),
R = R_e + k,
x = D*(A*sin(beta)*cos(theta)+R*cos(s+phi)*cos(theta+Omega)-R*sin(mu)*sin(s+phi)*sin(theta))*exp(theta/tan(alpha)),
y =  (-A*sin(beta)*sin(theta)-R*cos(s+phi)*sin(theta+Omega)-R*sin(mu)*sin(s+phi)*cos(theta))*exp(theta/tan(alpha)),
z =  (-A*cos(beta)+R*sin(s+phi)*cos(mu))*exp(theta/tan(alpha))
) %>%
dplyr::select(x, y, z)
}
molusc <-  mollusc()
require(ggplot2)
ggplot(molusc,aes(x, y)) +
geom_point(size = 0.03, alpha = 0.03) +
geom_path(size = 0.03, alpha = 0.03) +
theme_blankcanvas(margin_cm = 0.5)
ggplot(molusc,aes(x, y)) +
geom_point(size = 0.03, alpha = 0.03) +
geom_path(size = 0.03, alpha = 0.03)
require(dplyr)
mollusc <- function(n_s = 100, n_t = 400,
alpha = 80, beta = 40, phi = 55, mu = 30, Omega = 10, s_min = -270, s_max = 62,
A = 25, a = 12, b = 16, P = 2, W_1 = 1, W_2 = 1, N = 0, L = 0, D = 1,
theta_start = 0, theta_end = 10*pi) {
alpha <- alpha * pi / 180
beta <- beta * pi / 180
phi <- phi * pi / 180
mu <- mu * pi / 180
Omega <- Omega * pi / 180
s_min <- s_min * pi / 180
s_max <- s_max * pi / 180
P <- P * pi / 180
W_1 <- W_1 * pi / 180
W_2 <- W_2 * pi / 180
data.frame(expand.grid(seq(s_min, s_max, (s_max-s_min)/(n_s-1)),
seq(theta_start, theta_end, (theta_end-theta_start)/(n_t-1))) %>%
dplyr::rename(s = Var1, theta = Var2)) %>%
dplyr::mutate(
f_theta = ifelse(N == 0, Inf, 360/N*(theta*N/360-round(theta*N/360, 0))),
R_e = (a^(-2)*(cos(s))^2+b^(-2)*(sin(s))^2)^(-0.5),
k = L*exp(-(2*(s-P)/W_1)^2)*exp(-(2*f_theta/W_2)^2),
R = R_e + k,
x = D*(A*sin(beta)*cos(theta)+R*cos(s+phi)*cos(theta+Omega)-R*sin(mu)*sin(s+phi)*sin(theta))*exp(theta/tan(alpha)),
y =  (-A*sin(beta)*sin(theta)-R*cos(s+phi)*sin(theta+Omega)-R*sin(mu)*sin(s+phi)*cos(theta))*exp(theta/tan(alpha)),
z =  (-A*cos(beta)+R*sin(s+phi)*cos(mu))*exp(theta/tan(alpha))
) %>%
dplyr::select(x, y, z)
}
molusc <-  mollusc()
ggplot(molusc,aes(x, y)) +
geom_point(size = 0.03, alpha = 0.03,color="#C0C0C0") +
geom_path(size = 0.03, alpha = 0.03) +
theme_void()
require(dplyr)
mollusc <- function(n_s = 500, n_t = 800,
alpha = 80, beta = 40, phi = 55, mu = 30, Omega = 10, s_min = -270, s_max = 62,
A = 25, a = 12, b = 16, P = 2, W_1 = 1, W_2 = 1, N = 0, L = 0, D = 1,
theta_start = 0, theta_end = 10*pi) {
alpha <- alpha * pi / 180
beta <- beta * pi / 180
phi <- phi * pi / 180
mu <- mu * pi / 180
Omega <- Omega * pi / 180
s_min <- s_min * pi / 180
s_max <- s_max * pi / 180
P <- P * pi / 180
W_1 <- W_1 * pi / 180
W_2 <- W_2 * pi / 180
data.frame(expand.grid(seq(s_min, s_max, (s_max-s_min)/(n_s-1)),
seq(theta_start, theta_end, (theta_end-theta_start)/(n_t-1))) %>%
dplyr::rename(s = Var1, theta = Var2)) %>%
dplyr::mutate(
f_theta = ifelse(N == 0, Inf, 360/N*(theta*N/360-round(theta*N/360, 0))),
R_e = (a^(-2)*(cos(s))^2+b^(-2)*(sin(s))^2)^(-0.5),
k = L*exp(-(2*(s-P)/W_1)^2)*exp(-(2*f_theta/W_2)^2),
R = R_e + k,
x = D*(A*sin(beta)*cos(theta)+R*cos(s+phi)*cos(theta+Omega)-R*sin(mu)*sin(s+phi)*sin(theta))*exp(theta/tan(alpha)),
y =  (-A*sin(beta)*sin(theta)-R*cos(s+phi)*sin(theta+Omega)-R*sin(mu)*sin(s+phi)*cos(theta))*exp(theta/tan(alpha)),
z =  (-A*cos(beta)+R*sin(s+phi)*cos(mu))*exp(theta/tan(alpha))
) %>%
dplyr::select(x, y, z)
}
molusc <-  mollusc()
ggplot(molusc,aes(x, y)) +
geom_point(size = 0.03, alpha = 0.03,color="#C0C0C0") +
geom_path(size = 0.03, alpha = 0.03) +
theme_void()
ggplot(molusc,aes(x, y)) +
geom_point(size = 0.03, alpha = 0.03,color="red") +
geom_path(size = 0.03, alpha = 0.03) +
theme_void() +
theme(panel.background = elemect_rec(color="black"))
ggplot(molusc,aes(x, y)) +
geom_point(size = 0.03, alpha = 0.03,color="red") +
geom_path(size = 0.03, alpha = 0.03) +
theme_void() +
theme(panel.background = elemect_rect(color="black"))
ggplot(molusc,aes(x, y)) +
geom_point(size = 0.03, alpha = 0.03,color="red") +
geom_path(size = 0.03, alpha = 0.03) +
theme_void() +
theme(panel.background = element_rect(color="black"))
setwd("~/Documents/GitHub/Bayesian_Nuclear/BBN_Reactions/Be7/ApJBe7")
samp <- read.csv("MCMC_ApJ_ultimaterun.csv",header = T)
samp
apply(quantile,samp,1)
apply(1,samp,quantile)
apply(samp,1,quantile)
apply(samp,2,quantile)
apply(samp[,-1],2,quantile)
apply(en,2,quantile)
en <- samp[,c('e0_1','e0_2',
'e0_3', 'e0_4',
'e0_5', 'e0_6',
'e0_7')]
apply(en,2,quantile)
probBe7 <- function(x){quantile(x,probs=c(0.16, 0.5, 0.84))}
apply(en,2,probBe7 )
tabEr <- apply(en,2,probBe7)
tabEr[2,] - tabEr[1,]
tabEr[3,] - tabEr[2,]
tabEr[3,]
probBe7 <- function(x){
quantile(x,probs=c(0.16, 0.5, 0.84))
}
tabEr <- apply(en,2,probBe7)
formtab <- function(tab){
low <-  tab[2,] - tab[1,]
up <- tab[3,] - tab[2,]
mean <- tab[2,]
out <- data.frame(low,mean,up)
return(out)
}
formtab( tabEr)
tabEr
0.0054385762-0.0022134219
0.0022134219-0.0005740986
round(formtab(tabEr),5)
gan <- samp[,c('ga_1','ga_2', 'ga_3', 'ga_4', 'ga_5', 'ga_6', 'ga_7')]
tabga <- apply(gan,2,probBe7)
round(formtab( tabga ),5)
gbn <- samp[,c('gb_1','gb_2', 'gb_3', 'gb_4', 'gb_5', 'gb_6', 'gb_7')]
tabgb <- apply(gbn,2,probBe7)
round(formtab( tabgb ),5)
apply(samp,2,probBe7)
apply(samp[,c("ra","rb")],2,probBe7)
round(apply(samp[,c("ra","rb")],2,probBe7),5)
round(formtab(apply(samp[,c("ra","rb")],2,probBe7),5))
round(formtab(apply(samp[,c("ra","rb")],2,probBe7)),5)
round(formtab(apply(samp[,c("ra","rb")],2,probBe7)),2)
norm <- samp[,c("y.norm.1.","y.norm.2.",
"y.norm.3.","y.norm.4.",
"y.norm.5.","y.norm.6.",
"y.norm.7.",
"y.norm.8.",
"y.norm.9.","y.norm.10.")]
norm
round(formtab(apply(norm,2,probBe7)),2)
head(samp)
colnames(samp)
sigscat <- samp[,c("y.scat.1.","y.scat.2.",
"y.scat.3.","y.scat.4.",
"y.scat.5." ,"y.scat.6.",
"y.scat.7.",
"y.scat.8.",
"y.scat.9.","y.scat.10.")]
round(formtab(apply(sigscat,2,probBe7)),2)
sigscat
