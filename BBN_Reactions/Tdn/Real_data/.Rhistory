e1 ~  dnorm(0,0.1)T(0,)
gin ~  dnorm(0,pow(0.5,-2))T(0,)
gout ~ dnorm(0,pow(0.5,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
Normfit <- run.jags(data = model.data,
adapt = 5000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 10,
burnin = 4000,
sample = 10000,
n.chains = 4)
Normfit
traplot(Normfit  ,c("e1","ex", "gin", "gout"),style="plain")
denplot(Normfit  ,c("e1", "gin", "gout","ue"),style="plain")
Normfit
plot(Normfit, layout=c(3,4))
1/0.5^2
N <- 150
#obsx1 <- runif(N,0,0.7)
obsx1 <- exp(runif(N,log(1e-3),log(1)))
sd <- 0.1
obsy1 <- rnorm(N, Sfactor3(obsx1,0.0912,0.0912,2.93,0.0794,6,5,0),sd=sd)
M <- 150
xx <- seq(min(obsx1),max(obsx1),length.out = M)
model.data <- list(obsy = obsy1,    # Response variable
obsx =  obsx1,   # Predictors
#                   erry = errobsy1,
N = N, # Sample size
M = M,
xx = xx
)
#
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
#obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
obsy[i] ~ dnorm(sfactorTdn3(obsx[i], e1,0.0912, gin, gout,6,5,0),pow(tau, -2))
res[i] <- obsy[i]-sfactorTdn3(obsx[i], e1,0.0912, gin, gout,6,5,0)
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactorTdn3(xx[j], e1,0.0912, gin, gout,6,5,0)
}
# PRIORS
tau ~  dgamma(0.1,0.1)
e1 ~  dnorm(0,0.1)T(0,)
gin ~  dnorm(0,pow(0.5,-2))T(0,)
gout ~ dnorm(0,pow(0.5,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- run.jags(data = model.data,
adapt = 5000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 20,
burnin = 4000,
sample = 5000,
n.chains = 3)
Normfit <- run.jags(data = model.data,
adapt = 10000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 5,
burnin = 2000,
sample = 5000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
Normfit <- run.jags(data = model.data,
adapt = 20000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 10,
burnin = 1000,
sample = 5000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
Normfit
Normfit <- run.jags(data = model.data,
adapt = 30000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 1,
burnin = 1000,
sample = 10000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
# JAGS model with R2Jags;
Normfit <- run.jags(data = model.data,
adapt = 30000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 50,
burnin = 1000,
sample = 2000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
Normfit
65000/12
123500000/12
65000000*0.81
52650000/12
98280/7.8
998280/7.8
127984.6/12
1346940/7.8
172684.6/12
14000*3.2
2700*3.3
4*5
2700/5
2300+500
2800/5
3200+560
3760*3.3
3760*3.4
900*3.4
900*3.42
900*4
3700*4
830/1596
install.packages("rJava",type = "source",http://rforge.net")
install.packages("rJava",type = "source","http://rforge.net")
install.packages("rJava",type = "source",,"http://rforge.net")
# From: Bayesian Models for Astrophysical Data, Cambridge Univ. Press
# (c) 2017,  Joseph M. Hilbe, Rafael S. de Souza and Emille E. O. Ishida
#
# you are kindly asked to include the complete citation if you used this
# material in a publication
# Code 4.10 - Normal linear model in R using JAGS and including errors in variables
require(R2jags)
# Data
set.seed(1056)                   # set seed to replicate example
nobs = 1000                      # number of obs in model
sdobsx <- 1.25
truex <- rnorm(nobs,0,2.5)       # normal variable
errx <- rnorm(nobs, 0, sdobsx)
obsx <- truex + errx
beta1 <- -4
beta2 <- 7
sdy <- 1.25
sdobsy <- 2.5
erry <- rnorm(nobs, 0, sdobsy)
truey <- rnorm(nobs,beta1 + beta2*truex,sdy)
obsy <- truey + erry
K <- 2
model.data <- list(obsy = obsy,
obsx = obsx,
K = K,
errx = errx,
erry = erry,
N = nobs)
NORM_err <-" model{
# Diffuse normal priors for predictors
for (i in 1:K) { beta[i] ~ dnorm(0, 1e-3) }
# Uniform prior for standard deviation
tauy <- pow(sigma, -2)                               # precision
sigma ~ dunif(0, 100)                                # diffuse prior for standard deviation
# Diffuse normal priors for true x
for (i in 1:N){
x[i] ~ dnorm(0,1e-3)
}
# Likelihood
for (i in 1:N){
obsy[i] ~ dnorm(y[i],pow(erry[i],-2))
y[i] ~ dnorm(mu[i],tauy)
obsx[i] ~ dnorm(x[i],pow(errx[i],-2))
mu[i] <- beta[1]+beta[2]*x[i]
}
}"
# Initial values
inits <- function () {
list(beta = rnorm(K, 0, 0.01))
}
# Parameter to display and save
params <- c("beta", "sigma")
evfit <- jags(data = model.data,
inits = inits,
parameters = params,
model = textConnection(NORM_err),
n.chains = 3,
n.iter = 5000,
n.thin = 1,
n.burnin = 2500)
print(evfit,intervals=c(0.025, 0.975), digits=3)
# Data
set.seed(1056)                   # set seed to replicate example
nobs = 1000                      # number of obs in model
sdobsx <- 1.25
truex <- rnorm(nobs,0,2.5)       # normal variable
#errx <- rnorm(nobs, 0, sdobsx)
#obsx <- truex + errx
beta1 <- -4
beta2 <- 7
sdy <- 1.25
sdobsy <- 2.5
erry <- rnorm(nobs, 0, sdobsy)
truey <- rnorm(nobs,beta1 + beta2*truex,sdy)
obsy <- truey + erry
K <- 2
model.data <- list(obsy = obsy,
obsx = obsx,
K = K,
errx = errx,
erry = erry,
N = nobs)
NORM_err <-" model{
# Diffuse normal priors for predictors
for (i in 1:K) { beta[i] ~ dnorm(0, 1e-3) }
# Uniform prior for standard deviation
tauy <- pow(sigma, -2)                               # precision
sigma ~ dunif(0, 100)                                # diffuse prior for standard deviation
# Likelihood
for (i in 1:N){
obsy[i] ~ dnorm(y[i],pow(erry[i],-2))
y[i] ~ dnorm(mu[i],tauy)
mu[i] <- beta[1]+beta[2]*truex[i]
}
}"
# Initial values
inits <- function () {
list(beta = rnorm(K, 0, 0.01))
}
# Parameter to display and save
params <- c("beta", "sigma")
evfit <- jags(data = model.data,
inits = inits,
parameters = params,
model = textConnection(NORM_err),
n.chains = 3,
n.iter = 5000,
n.thin = 1,
n.burnin = 2500)
print(evfit,intervals=c(0.025, 0.975), digits=3)
errx
# Data
set.seed(1056)                   # set seed to replicate example
nobs = 1000                      # number of obs in model
sdobsx <- 1.25
truex <- rnorm(nobs,0,2.5)       # normal variable
#errx <- rnorm(nobs, 0, sdobsx)
#obsx <- truex + errx
obsx <- truex
beta1 <- -4
beta2 <- 7
sdy <- 1.25
sdobsy <- 2.5
erry <- rnorm(nobs, 0, sdobsy)
truey <- rnorm(nobs,beta1 + beta2*truex,sdy)
obsy <- truey + erry
K <- 2
model.data <- list(obsy = obsy,
obsx = obsx,
K = K,
errx = errx,
erry = erry,
N = nobs)
NORM_err <-" model{
# Diffuse normal priors for predictors
for (i in 1:K) { beta[i] ~ dnorm(0, 1e-3) }
# Uniform prior for standard deviation
tauy <- pow(sigma, -2)                               # precision
sigma ~ dunif(0, 100)                                # diffuse prior for standard deviation
# Likelihood
for (i in 1:N){
obsy[i] ~ dnorm(y[i],pow(erry[i],-2))
y[i] ~ dnorm(mu[i],tauy)
mu[i] <- beta[1]+beta[2]*obsx[i]
}
}"
# Initial values
inits <- function () {
list(beta = rnorm(K, 0, 0.01))
}
# Parameter to display and save
params <- c("beta", "sigma")
evfit <- jags(data = model.data,
inits = inits,
parameters = params,
model = textConnection(NORM_err),
n.chains = 3,
n.iter = 5000,
n.thin = 1,
n.burnin = 2500)
print(evfit,intervals=c(0.025, 0.975), digits=3)
erry
print(evfit,intervals=c(0.025, 0.975), digits=3)
# Level of  mistake in the reported errors
Lambda <- 0.5
model.data <- list(obsy = obsy,
obsx = obsx,
K = K,
errx = errx,
erry = Lambda*erry,
N = nobs)
NORM_err <-" model{
# Diffuse normal priors for predictors
for (i in 1:K) { beta[i] ~ dnorm(0, 1e-3) }
# Uniform prior for standard deviation
tauy <- pow(sigma, -2)                               # precision
sigma ~ dunif(0, 100)                                # diffuse prior for standard deviation
# Likelihood
for (i in 1:N){
obsy[i] ~ dnorm(y[i],pow(erry[i],-2))
y[i] ~ dnorm(mu[i],tauy)
mu[i] <- beta[1]+beta[2]*obsx[i]
}
}"
# Initial values
inits <- function () {
list(beta = rnorm(K, 0, 0.01))
}
# Parameter to display and save
params <- c("beta", "sigma")
evfit <- jags(data = model.data,
inits = inits,
parameters = params,
model = textConnection(NORM_err),
n.chains = 3,
n.iter = 5000,
n.thin = 1,
n.burnin = 2500)
print(evfit,intervals=c(0.025, 0.975), digits=3)
setwd("~/")
erry
library(shiny)
library(DT)
shinyApp(
ui = fluidPage(
dataTableOutput('table'),
verbatimTextOutput('hoverIndex')
),
server = function(server, input, output) {
output$hoverIndex <- renderText({
paste("hover column info", input$hoverIndexJS)
})
output$table <- renderDataTable({
datatable(data.frame(`A` = 1:5, `B` = 11:15, `C` = LETTERS[1:5]),
rownames = F,
callback = JS("
table.on('mouseenter', 'td', function() {
Shiny.onInputChange('hoverIndexJS', this.innerHTML);
});
return table;
")
)
})
}
)
175/8
175*4
library("TDA", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
Diag <- matrix(c(0, 0, 10, 1, 0, 3, 1, 3, 8), ncol = 3, byrow = TRUE)
DiagLim <- 10
colnames(Diag) <- c("dimension", "Birth", "Death")
#persistence landscape
tseq <- seq(0,DiagLim, length = 1000)
Land <- landscape(Diag, dimension = 1, KK = 1, tseq)
par(mfrow = c(1,2))
plot.diagram(Diag)
plot(tseq, Land, type = "l", xlab = "t", ylab = "landscape", asp = 1)
library(dplyr)
library(tidyr)
library(DT)
library(sparkline)
dat <- readRDS("data.rds")
datatable(dat, rownames = FALSE)
dat <- iris3
datatable(dat, rownames = FALSE)
dat <- iris
datatable(dat, rownames = FALSE)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
d1 <- datatable(dat_t1, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
js <- "function(data, type, full){ return '<span class=spark>' + data + '</span>' }"
colDefs1 <- list(list(targets = c(1:3), render = JS(js)))
d1 <- datatable(dat_t1, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
range(filter(dat, Var == "Species")$Val)
dat
r <- range(filter(dat, Species == "setosa")$Val)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
r <- range(filter(dat, Species == "setosa")$Val)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
range(filter(dat, Species == "setosa")$Val)
filter(dat, Species == "setosa")
range(dat$Petal.Length)
r <- range(dat$Petal.Length)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
datatable(dat_t1, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
datatable(dat, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
r <- range(dat$Petal.Length)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
d1 <- datatable(dat, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
d1
4*12000
4200*12
80000/12
400000/12
300000/12
40000/12
3512-79.98
3432.02-50
9200+3300
12500+500
13000+1700
14700*3.7
54390+45000
setwd("~/Documents/GitHub/Bayesian_Nuclear/BBN_Reactions/Tdn/Real_data")
ssDat <- read.table("Tdn_DREAM.dat",header = T)
colnames(ssDat)
Corr_chain <- ggs(as.mcmc(ssDat[,c("e0","er","gd2","gp2","ad","an","ue")])) %>%
as_tibble() %>%
mutate(Parameter = factor(Parameter, levels = c("e0","er","gd2","gn2","ad","an","ue"))) %>%
mutate(Parameter  = factor(Parameter, labels = c("E[0]~(MeV)","E[r]~(MeV)","gamma[d]^2~(MeV)",
"gamma[n]^2~(MeV)","a[d]~(fm)",
"a[n]~(fm)","U[e]~(eV)")))
require(dplyr)
ssDat <- read.table("Tdn_DREAM.dat",header = T)
Corr_chain <- ggs(as.mcmc(ssDat[,c("e0","er","gd2","gp2","ad","an","ue")])) %>%
as_tibble() %>%
mutate(Parameter = factor(Parameter, levels = c("e0","er","gd2","gn2","ad","an","ue"))) %>%
mutate(Parameter  = factor(Parameter, labels = c("E[0]~(MeV)","E[r]~(MeV)","gamma[d]^2~(MeV)",
"gamma[n]^2~(MeV)","a[d]~(fm)",
"a[n]~(fm)","U[e]~(eV)")))
require(ggmcmc)
ssDat <- read.table("Tdn_DREAM.dat",header = T)
Corr_chain <- ggs(as.mcmc(ssDat[,c("e0","er","gd2","gp2","ad","an","ue")])) %>%
as_tibble() %>%
mutate(Parameter = factor(Parameter, levels = c("e0","er","gd2","gn2","ad","an","ue"))) %>%
mutate(Parameter  = factor(Parameter, labels = c("E[0]~(MeV)","E[r]~(MeV)","gamma[d]^2~(MeV)",
"gamma[n]^2~(MeV)","a[d]~(fm)",
"a[n]~(fm)","U[e]~(eV)")))
require(msm);require(mcmcplots);
require(ggridges);require(plyr);require(MASS)
source("..//..//auxiliar_functions/pair_wise_plot.R")
Corr_chain <- ggs(as.mcmc(ssDat[,c("e0","er","gd2","gp2","ad","an","ue")])) %>%
as_tibble() %>%
mutate(Parameter = factor(Parameter, levels = c("e0","er","gd2","gn2","ad","an","ue"))) %>%
mutate(Parameter  = factor(Parameter, labels = c("E[0]~(MeV)","E[r]~(MeV)","gamma[d]^2~(MeV)",
"gamma[n]^2~(MeV)","a[d]~(fm)",
"a[n]~(fm)","U[e]~(eV)")))
Corr_chain <- ggs(as.mcmc(ssDat[,c("e0","er","gd2","gn2","ad","an","ue")])) %>%
as_tibble() %>%
mutate(Parameter = factor(Parameter, levels = c("e0","er","gd2","gn2","ad","an","ue"))) %>%
mutate(Parameter  = factor(Parameter, labels = c("E[0]~(MeV)","E[r]~(MeV)","gamma[d]^2~(MeV)",
"gamma[n]^2~(MeV)","a[d]~(fm)",
"a[n]~(fm)","U[e]~(eV)")))
pair_wise_plot(Corr_chain)
