data {
int N;
int num_knots;
vector[num_knots] knots;
int spline_degree;
real Y[N];
real X[N];
}
transformed data {
int num_basis = num_knots + spline_degree - 1; // total number of B-splines
matrix[num_basis, N] B;  // matrix of B-splines
vector[spline_degree + num_knots] ext_knots_temp;
vector[2*spline_degree + num_knots] ext_knots; // set of extended knots
ext_knots_temp = append_row(rep_vector(knots[1], spline_degree), knots);
ext_knots = append_row(ext_knots_temp, rep_vector(knots[num_knots], spline_degree));
for (ind in 1:num_basis)
B[ind,:] = to_row_vector(build_b_spline(X, to_array_1d(ext_knots), ind, spline_degree + 1));
B[num_knots + spline_degree - 1, N] = 1;
}
parameters {
row_vector[num_basis] a_raw;
real a0;
real<lower=0> sigma;
real<lower=0> tau;
}
transformed parameters {
row_vector[num_basis] a;
vector[N] Y_hat;
a[1] = a_raw[1];
for (i in 2:num_basis)
a[i] = a[i-1] + a_raw[i]*tau;
Y_hat = a0*to_vector(X) + to_vector(a*B);
}
model {
a_raw ~ normal(0, 1);
tau ~ cauchy(0, 1);
sigma ~ cauchy(0, 1);
Y ~ normal(Y_hat, sigma);
}
generated quantities{
vector[N] mu_pred;
// Posterior parameter distribution of the mean
mu_pred = a0*to_vector(X) + to_vector(a*B);
}
"
fit <- stan(model_code = stan_model,
data = stan_data,
seed = 42,
chains = 3,
iter =1500,
cores= 3,
warmup=750)
fit
Y_mean <- extract(fit, "mu_pred")
Y_mean_cred <- apply(Y_mean$mu_pred, 2, quantile, c(0.05, 0.95))
Y_mean_mean <- apply(Y_mean$mu_pred, 2, mean)
fitdat <- data.frame(x = XX, y = Y_mean_mean, lwr1 = Y_mean_cred[1,],upr1 = Y_mean_cred[2,])
ggplot(data=gdat,aes(x=x,y=y)) +
geom_point() +
geom_line(data=fitdat,aes(x=x,y=y)) +
geom_ribbon(data=fitdat,aes(x=x,ymin=lwr1, ymax=upr1,y=NULL),fill=c("gray50"),alpha=0.5) +
theme_bw()
library("splines")
library("rstan")
X <- seq(from=-5, to=5, by=.1) # generating inputs
B <- t(bs(X, knots=seq(-5,5,1), degree=3, intercept = TRUE)) # creating the B-splines
N <- length(X)
num_basis <- nrow(B)
a0 <- 0.2 # intercept
a <- rnorm(num_basis, 0, 1) # coefficients of B-splines
Y_true <- as.vector(a0*X + a%*%B) # generating the output
Y <- Y_true + rnorm(length(X),0,.2) # adding noise
# Grid for prediction values
XX <- seq(from=-5, to=5, by=.05) # generating inputs
BB <- t(bs(XX, knots=seq(-5,5,1), degree=3, intercept = TRUE)) # creating the B-splines
M <- length(XX)
num_basis2 <- nrow(BB)
gdat <- data.frame(y=Y,x=X)
stan_data  <- list(Y = Y,
X = X,
num_knots = 10,
knots = seq(min(X),max(X),length.out = 10),
spline_degree = 4,
N = N
)
stan_model= "
functions {
vector build_b_spline(real[] t, real[] ext_knots, int ind, int order);
vector build_b_spline(real[] t, real[] ext_knots, int ind, int order) {
vector[size(t)] b_spline;
vector[size(t)] w1 = rep_vector(0, size(t));
vector[size(t)] w2 = rep_vector(0, size(t));
if (order==1)
for (i in 1:size(t))
b_spline[i] = (ext_knots[ind] <= t[i]) && (t[i] < ext_knots[ind+1]);
else {
if (ext_knots[ind] != ext_knots[ind+order-1])
w1 = (to_vector(t) - rep_vector(ext_knots[ind], size(t))) /
(ext_knots[ind+order-1] - ext_knots[ind]);
if (ext_knots[ind+1] != ext_knots[ind+order])
w2 = 1 - (to_vector(t) - rep_vector(ext_knots[ind+1], size(t))) /
(ext_knots[ind+order] - ext_knots[ind+1]);
b_spline = w1 .* build_b_spline(t, ext_knots, ind, order-1) +
w2 .* build_b_spline(t, ext_knots, ind+1, order-1);
}
return b_spline;
}
}
data {
int N;
int num_knots;
vector[num_knots] knots;
int spline_degree;
real Y[N];
real X[N];
}
transformed data {
int num_basis = num_knots + spline_degree - 1; // total number of B-splines
matrix[num_basis, N] B;  // matrix of B-splines
vector[spline_degree + num_knots] ext_knots_temp;
vector[2*spline_degree + num_knots] ext_knots; // set of extended knots
ext_knots_temp = append_row(rep_vector(knots[1], spline_degree), knots);
ext_knots = append_row(ext_knots_temp, rep_vector(knots[num_knots], spline_degree));
for (ind in 1:num_basis)
B[ind,:] = to_row_vector(build_b_spline(X, to_array_1d(ext_knots), ind, spline_degree + 1));
B[num_knots + spline_degree - 1, N] = 1;
}
parameters {
row_vector[num_basis] a_raw;
real a0;
real<lower=0> sigma;
real<lower=0> tau;
}
transformed parameters {
row_vector[num_basis] a;
vector[N] Y_hat;
a[1] = a_raw[1];
for (i in 2:num_basis)
a[i] = a[i-1] + a_raw[i]*tau;
Y_hat = a0*to_vector(X) + to_vector(a*B);
}
model {
a_raw ~ normal(0, 1);
tau ~ cauchy(0, 1);
sigma ~ cauchy(0, 1);
Y ~ normal(Y_hat, sigma);
}
generated quantities{
vector[N] mu_pred;
// Posterior parameter distribution of the mean
mu_pred = a0*to_vector(X) + to_vector(a*B);
}
"
fit <- stan(model_code = stan_model,
data = stan_data,
seed = 42,
chains = 3,
iter =1500,
cores= 3,
warmup=750)
Y_mean <- extract(fit, "mu_pred")
Y_mean_cred <- apply(Y_mean$mu_pred, 2, quantile, c(0.05, 0.95))
Y_mean_mean <- apply(Y_mean$mu_pred, 2, mean)
fitdat <- data.frame(x = XX, y = Y_mean_mean, lwr1 = Y_mean_cred[1,],upr1 = Y_mean_cred[2,])
ggplot(data=gdat,aes(x=x,y=y)) +
geom_point() +
geom_line(data=fitdat,aes(x=x,y=y)) +
geom_ribbon(data=fitdat,aes(x=x,ymin=lwr1, ymax=upr1,y=NULL),fill=c("gray50"),alpha=0.5) +
theme_bw()
fitdat <- data.frame(x = X, y = Y_mean_mean, lwr1 = Y_mean_cred[1,],upr1 = Y_mean_cred[2,])
ggplot(data=gdat,aes(x=x,y=y)) +
geom_point() +
geom_line(data=fitdat,aes(x=x,y=y)) +
geom_ribbon(data=fitdat,aes(x=x,ymin=lwr1, ymax=upr1,y=NULL),fill=c("gray50"),alpha=0.5) +
theme_bw()
install.packages("tcltk2")
install.packages("sm")
install.packages("magicaxis")
29.66+20.34+7.63+42.37
17.24+21.84+9.2+51.72
tmp <- installed.packages()
installedpkgs.new <- as.vector(tmp[is.na(tmp[,"Priority"]), 1])
missing <- setdiff(installedpkgs, installedpkgs.new)
install.packages(missing)
update.packages()
tmp <- installed.packages()
installedpkgs.new <- as.vector(tmp[is.na(tmp[,"Priority"]), 1])
missing <- setdiff(installedpkgs, installedpkgs.new)
install.packages(missing)
update.packages()
require(rjags)
require(nuclear)
setwd("~/Documents/GitHub/Bayesian_Nuclear/BBN_Reactions/Tdn/Real_data")
# 3Hedp analysis
#
# purpose: Real  DATA
#
# - 5 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorHe3dp(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
######################################################################
# preparation: remove all variables from the work space
rm(list=ls())
set.seed(123)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
## Read DATA
ensamble <- read.csv("ensamble_Tdn_extra.csv",header = T) %>%  filter(E <= 0.3)
#filter(dat!= "Mag75")
#%>% filter(E <= 0.5) %>%   filter(dat!= "Arn53") %>%
# droplevels(ensamble$dat)
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
require(gsl)
load.module("nuclear")
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(gsl)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(gsl)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
install.packages("rjags")
load.module("nuclear")
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(gsl)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
install.packages("~/Downloads/rjags_4-4.tar", repos = NULL)
install.packages("~/Downloads/rjags_4-4.tar", type="source")
install.packages("~/Downloads/rjags_4-4.tar")
install.packages("~/Downloads/rjags_4-4.tgz")
install.packages("~/Downloads/rjags_4-4.tar")
install.packages(c("R2jags", "coda", "R2WinBUGS", "lattice", "rjags"))
install.packages(c("R2jags", "coda", "R2WinBUGS", "lattice", "rjags"))
load.module("nuclear")
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(gsl)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(gsl)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(gsl)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
install.packages("rjags")
library(rjags);
load.module("nuclear")
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(gsl)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
install.packages("rjags",type="source")
install.packages("rjags", type = "source")
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(gsl)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
install.packages("gsl", type = "source")
install.packages("gsl", type = "source")
install.packages("RcppGSL", type = "source")
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(gsl)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
setwd("~/Documents/GitHub/Bayesian_Nuclear/BBN_Reactions/Tdn/Real_data")
ensamble <- read.csv("ensamble_Tdn_extra.csv",header = T) %>%  filter(E <= 0.3)
#filter(dat!= "Mag75")
#%>% filter(E <= 0.5) %>%   filter(dat!= "Arn53") %>%
# droplevels(ensamble$dat)
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
# Literature
#  0.35779   # resonance energy
#  1.0085    # reduced width incoming
#  0.025425   # reduced width outgoing
N <- nrow(ensamble)
obsy <- ensamble$S    # Response variable
obsx <-  ensamble$E   # Predictors
erry <- ensamble$Stat
set <- ensamble$dat
lab <- ensamble$invK
syst = c(unique(ensamble$Syst))
#syst <- syst[-3]
M <- 500
xx <- exp(seq(log(min(obsx)),log(max(obsx)),length.out = M))
model.data <- list(obsy = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble), # Sample size
syst = syst,
Nre = Nre,
re = re,
M = M,
xx = xx
)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactorTdn(obsx[i], e1, ex,gin, gout,ri,rf,0),pow(tau, -2))
#y[i] ~ dnorm(scale[re[i]]*sfactorTdn_old(obsx[i], e1, gin, gout),pow(tau, -2))
#y[i] ~ dnorm(sfactorTdn_old(obsx[i], e1, gin, gout),pow(tau, -2))
#obsy[i] ~ dnorm(scale[re[i]]*sfactorTdn(obsx[i], e1,ex, gin, gout,ri,rf,0), pow(tau, -2))
res[i] <- obsy[i]-sfactorTdn_old(obsx[i], e1, gin, gout)
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1, ex,gin, gout,ri,rf,0)
yx0[j] ~ dnorm(mux0[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
#Nsyst[k] ~ dnorm(0,tt)T(0,)
}
#ue ~ dnorm(0,pow(0.1,-2))T(0,)
#for (k in 1:Nre){
#scale[k] ~ dnorm(1,pow(taus[k],-2))T(0,)
#taus[k] ~ dunif(0,0.5)
#}
# PRIORS
# Wigner limit: wl = hbar^2/(m_red a_c^2) = 41.80159/(M_red a_c^2)
#
# deuteron channel: wl_d = 41.80159/(1.207357 a_c^2) = 34.6224/a_c^2
# neutron channel:  wl_n = 41.80159/(0.805597 a_c^2) = 51.8889/a_c^2
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
tau ~ dnorm(0, pow(1,-2))T(0,)
#e1 ~  dnorm(0, pow(1,-2))T(0,)
e1 ~  dbeta(0.5,0.5)
ex <- e1
Ngin ~ dbeta(0.5,0.5)
Ngout ~ dbeta(0.5,0.5)
gin  <-  3*Ngin
gout <- 3*Ngout
rf ~  dnorm(5,pow(0.1,-2))T(0,)
ri ~  dnorm(6,pow(0.1,-2))T(0,)
#gin ~  dnorm(0, pow(3,-2))T(0,)
#gout ~ dnorm(0, pow(3,-2))T(0,)
}"
inits <- function () { list(e1 = runif(1,0.01,0.1),Ngout=runif(1,0.01,0.5),Ngin=runif(1,0.01,0.9)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
set.seed(43)
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("e1", "gin", "gout","tau", "ri","rf","RSS","mux0","scale"),
model  = textConnection(Model),
n.thin = 10,
n.chains = 3,
n.burnin = 5000,
n.iter = 10000)
temp <- Normfit
temp <- update(temp, n.thin = 10, n.iter = 10000)
jagsresults(x = Normfit , params = c("e1", "gin", "gout","scale","ri","rf","tau"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
RSS <- as.matrix(as.mcmc(Normfit)[,c("RSS")])
rss0 <- function(x) crossprod(x-mean(x))[1]
1-mean(RSS)/rss0(obsy)
12.5/2
6.25/2
log(1024)
sqrt(246)
sqrt(266)
