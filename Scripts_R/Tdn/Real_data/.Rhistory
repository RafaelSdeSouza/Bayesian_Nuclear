logmu4 <- log(1.0)       # median of factor uncertainty is 1.0
logsigma4 <- log(1.040)  # factor uncertainty is 1.020, i.e., 2.0% for Arn53
}', file={f <- tempfile()})
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
n.adapt  <- 2000   # pick a larger value !!!
n.burnin <- 10000
# n.update <- 1000
n.iter   <- 5000
n.chains <- 3
n.thin   <- 1
# n.adapt  <- 20000
# n.update <- 5000
# n.iter   <- 10000
# n.chains <- 3
# n.thin   <- 1
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model;
ourmodel <- jags.model(f, data = list('obsx1' = obsx1, ## jags wants all data in a list
'obsy1' = obsy1,
'errobsy1' = errobsy1,
'obsx2' = obsx2,
'obsy2' = obsy2,
'errobsy2' = errobsy2,
'obsx3' = obsx3,
'obsy3' = obsy3,
'errobsy3' = errobsy3,
'obsx4' = obsx4,
'obsy4' = obsy4,
'errobsy4' = errobsy4),
#    inits = list(e1 = 0.09, gi = 2.9, gf = 0.09),
n.chains = n.chains,
n.adapt = n.adapt)
# burnin
# update(ourmodel, n.update, progress.bar="none")
# variable.names are variables to be recorded in output file of samples
mcmcChain <- coda.samples(ourmodel,
variable.names=c('e1', 'ex', 'gi', 'gf', 'intrscat',
'n.norm1', 'n.norm2', 'n.norm3', 'n.norm4',
'ri', 'rf','ue'),
n.iter=n.iter, n.thin=n.thin)
effectiveSize(mcmcChain )
plot(mcmcChain)
######################################################################
cat('model {
# LIKELIHOOD
# systematic error as normalization factor n.norm...
# ue is the electron screening potential for normal kinematics
for (i in 1:length(obsx1)) {
# measured number of decays including exp stat uncertainties
obsy1[i] ~ dnorm(ym1[i], pow(errobsy1[i], -2))
# measured number of decays including exp syst uncertainties
ym1[i] <- n.norm1 * ya1[i]
# actual number of decays subject to stat fluctuations
ya1[i] ~ dnorm(yt1[i], pow(intrscat, -2))
# true number of decays
yt1[i] <- sfactorTdn(obsx1[i], e1, ex, gi, gf, ri, rf, ue)
}
for (i in 1:length(obsx2)) {
# measured number of decays including exp stat uncertainties
obsy2[i] ~ dnorm(ym2[i], pow(errobsy2[i], -2))
# measured number of decays including exp syst uncertainties
ym2[i] <- n.norm2 * ya2[i]
# actual number of decays subject to stat fluctuations
ya2[i] ~ dnorm(yt2[i], pow(intrscat, -2))
# true number of decays
yt2[i] <- sfactorTdn(obsx2[i], e1, ex, gi, gf, ri, rf, ue)
}
for (i in 1:length(obsx3)) {
# measured number of decays including exp stat uncertainties
obsy3[i] ~ dnorm(ym3[i], pow(errobsy3[i], -2))
# measured number of decays including exp syst uncertainties
ym3[i] <- n.norm3 * ya3[i]
# actual number of decays subject to stat fluctuations
ya3[i] ~ dnorm(yt3[i], pow(intrscat, -2))
# true number of decays
yt3[i] <- sfactorTdn(obsx3[i], e1, ex, gi, gf, ri, rf, ue)
}
for (i in 1:length(obsx4)) {
# measured number of decays including exp stat uncertainties
obsy4[i] ~ dnorm(ym4[i], pow(errobsy4[i], -2))
# measured number of decays including exp syst uncertainties
ym4[i] <- n.norm4 * ya4[i]
# actual number of decays subject to stat fluctuations
ya4[i] ~ dnorm(yt4[i], pow(intrscat, -2))
# true number of decays
yt4[i] <- sfactorTdn(obsx4[i], e1, ex, gi, gf, ri, rf, ue)
}
# PRIORS
#
# Barker values:
# E1  = 0.0912 MeV
# g^2_in = 2.93 MeV         ! reduced width of deuteron
# g^2_out = 0.0794 MeV      ! reduced width of neutron
#
# Ex = 0.0912 MeV
# ri = 6.0 fm
# rf = 5.0 fm
#
# e1:       eigenenergy
# ex:       level shift is set zero at Ex
# gi,gf:    initial reduced width, final reduced width [gi,gf = gamma^2]
#
# Wigner limit: wl = hbar^2/(m_red a_c^2) = 41.80159/(M_red a_c^2)
#
# deuteron channel: wl_d = 41.80159/(1.207357 a_c^2) = 34.6224/a_c^2
# neutron channel:  wl_n = 41.80159/(0.805597 a_c^2) = 51.8889/a_c^2
wl_d <- 34.6224*pow(ri, -2)
wl_n <- 51.8889*pow(rf, -2)
#
###################
# Barker values for radii and boundary condition parameters
ri ~  dnorm(5.0,50)
rf ~ dnorm(5.0,50)
ex <- e1                # level shift zero at ex
ue <- 0.0                     # zero electron screening potential
intrscat ~ dunif(0, 5)        # certainly less than 5 MeVb
#  e1 ~ dnorm(0, 1)T(0,)
e1 ~ dunif(0.0, 1.0)          # postive since we see sigma peak
gi ~ dunif(0.0, 1*wl_d)      # x times Wigner limit
gf ~ dunif(0.0, 1*wl_n)      # x times Wigner limit
#  gi ~ dunif(0.01, 10)
#  gf ~ dunif(0.01, 10)
#  ue ~ dunif(0, 0.01)          # certainly less than 10 keV
################
# systematic errors as normalization factors
### lognormal density:
# log(): natural logarithm
n.norm1 ~ dlnorm(logmu1, pow(logsigma1, -2))
logmu1 <- log(1.0)       # median of factor uncertainty is 1.0
logsigma1 <- log(1.0126) # factor uncertainty is 1.0126, i.e. 1.26% for Jar84
n.norm2 ~ dlnorm(logmu2, pow(logsigma2, -2))
logmu2 <- log(1.0)       # median of factor uncertainty is 1.0
logsigma2 <- log(100.0)  # factor uncertainty very large since Bro87 used
# the normalization of Jar84
n.norm3 ~ dlnorm(logmu3, pow(logsigma3, -2))
logmu3 <- log(1.0)       # median of factor uncertainty is 1.0
logsigma3 <- log(1.025)  # factor uncertainty is 1.025, i.e., 2.5% for Kob66
n.norm4 ~ dlnorm(logmu4, pow(logsigma4, -2))
logmu4 <- log(1.0)       # median of factor uncertainty is 1.0
logsigma4 <- log(1.1)  # factor uncertainty is 1.020, i.e., 2.0% for Arn53
}', file={f <- tempfile()})
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
n.adapt  <- 2000   # pick a larger value !!!
n.burnin <- 10000
# n.update <- 1000
n.iter   <- 5000
n.chains <- 3
n.thin   <- 1
# n.adapt  <- 20000
# n.update <- 5000
# n.iter   <- 10000
# n.chains <- 3
# n.thin   <- 1
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model;
ourmodel <- jags.model(f, data = list('obsx1' = obsx1, ## jags wants all data in a list
'obsy1' = obsy1,
'errobsy1' = errobsy1,
'obsx2' = obsx2,
'obsy2' = obsy2,
'errobsy2' = errobsy2,
'obsx3' = obsx3,
'obsy3' = obsy3,
'errobsy3' = errobsy3,
'obsx4' = obsx4,
'obsy4' = obsy4,
'errobsy4' = errobsy4),
#    inits = list(e1 = 0.09, gi = 2.9, gf = 0.09),
n.chains = n.chains,
n.adapt = n.adapt)
# burnin
# update(ourmodel, n.update, progress.bar="none")
# variable.names are variables to be recorded in output file of samples
mcmcChain <- coda.samples(ourmodel,
variable.names=c('e1', 'ex', 'gi', 'gf', 'intrscat',
'n.norm1', 'n.norm2', 'n.norm3', 'n.norm4',
'ri', 'rf','ue'),
n.iter=n.iter, n.thin=n.thin)
effectiveSize(mcmcChain )
plot(mcmcChain)
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/Tdn/Real_data")
# 3Hedp analysis
#
# purpose: Real  DATA
#
# - 5 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorHe3dp(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
######################################################################
# preparation: remove all variables from the work space
rm(list=ls())
set.seed(123)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
## Read DATA
ensamble <- read.csv("ensamble_Tdn.csv",header = T)
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
ik <- as.numeric(ensamble$invK)
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
# Literature
#  0.35779   # resonance energy
#  1.0085    # reduced width incoming
#  0.025425   # reduced width outgoing
N <- nrow(ensamble)
obsy <- ensamble$S    # Response variable
obsx <-  ensamble$E   # Predictors
erry <- ensamble$Stat
set <- ensamble$dat
lab <- ensamble$invK
syst = c(unique(ensamble$Syst))
#syst <- syst[-3]
M <- 500
xx <- seq(min(obsx),max(obsx),length.out = M)
model.data <- list(obsy = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble), # Sample size
syst = syst,
Nre = Nre,
re = re,
Nik = Nik,
ik  = ik,
M = M,
xx = xx
)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
#y[i] ~ dnorm(scale[re[i]]*sfactorTdn(obsx[i], e1, ex,gin, gout,ri,rf,ue[ik[i]]),pow(tau, -2))
y[i] ~ dnorm(scale[re[i]]*sfactorTdn(obsx[i], e1,ex, gin, gout,ri,rf,0),pow(tau, -2))
res[i] <- obsy[i]-sfactorTdn(obsx[i], e1,ex, gin, gout,ri,rf,0)
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1,ex, gin, gout,ri,rf,0)
yx0[j] ~ dnorm(mux0[j],pow(tau,-2))
# No inverse Kinematics
#mux1[j] <- sfactorTdn(xx[j], e1, gin, gout,ri,rf,ue[1])
#yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
#mux2[j] <- sfactorTdn(xx[j], e1, gin, gout,ri,rf,ue[2])
#yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
#for (z in 1:Nik){
#ue[z] ~ dnorm(0,1e3)T(0,)
#}
# PRIORS
# Wigner limit: wl = hbar^2/(m_red a_c^2) = 41.80159/(M_red a_c^2)
#
# deuteron channel: wl_d = 41.80159/(1.207357 a_c^2) = 34.6224/a_c^2
# neutron channel:  wl_n = 41.80159/(0.805597 a_c^2) = 51.8889/a_c^2
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
tau ~  dt(0, pow(5,-2), 1)T(0,)
e1 ~  dnorm(0,0.1)T(0,)
ex <- e1
rf ~  dnorm(5,pow(0.1,-2))T(0,)
ri ~  dnorm(6,pow(0.1,-2))T(0,)
gin ~  dnorm(0,pow(0.5,-2))T(0,)
gout ~ dnorm(0,pow(0.5,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
adapt = 15000,
method="rjags",
monitor = c("e1","ex", "gin", "gout","ue","tau", "ri","rf","RSS","mux0","mux1","mux2","scale"),
model  = Model,
thin = 50,
n.chains = 4,
burnin = 15000,
sample = 30000)
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/Tdn/Real_data")
# 3Hedp analysis
#
# purpose: Real  DATA
#
# - 5 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorHe3dp(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
######################################################################
# preparation: remove all variables from the work space
rm(list=ls())
set.seed(123)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
## Read DATA
ensamble <- read.csv("ensamble_Tdn.csv",header = T)
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
ik <- as.numeric(ensamble$invK)
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
# Literature
#  0.35779   # resonance energy
#  1.0085    # reduced width incoming
#  0.025425   # reduced width outgoing
N <- nrow(ensamble)
obsy <- ensamble$S    # Response variable
obsx <-  ensamble$E   # Predictors
erry <- ensamble$Stat
set <- ensamble$dat
lab <- ensamble$invK
syst = c(unique(ensamble$Syst))
#syst <- syst[-3]
M <- 500
xx <- seq(min(obsx),max(obsx),length.out = M)
model.data <- list(obsy = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble), # Sample size
syst = syst,
Nre = Nre,
re = re,
Nik = Nik,
ik  = ik,
M = M,
xx = xx
)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
#y[i] ~ dnorm(scale[re[i]]*sfactorTdn(obsx[i], e1, ex,gin, gout,ri,rf,ue[ik[i]]),pow(tau, -2))
y[i] ~ dnorm(scale[re[i]]*sfactorTdn(obsx[i], e1,ex, gin, gout,ri,rf,0),pow(tau, -2))
res[i] <- obsy[i]-sfactorTdn(obsx[i], e1,ex, gin, gout,ri,rf,0)
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1,ex, gin, gout,ri,rf,0)
yx0[j] ~ dnorm(mux0[j],pow(tau,-2))
# No inverse Kinematics
#mux1[j] <- sfactorTdn(xx[j], e1, gin, gout,ri,rf,ue[1])
#yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
#mux2[j] <- sfactorTdn(xx[j], e1, gin, gout,ri,rf,ue[2])
#yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
#for (z in 1:Nik){
#ue[z] ~ dnorm(0,1e3)T(0,)
#}
# PRIORS
# Wigner limit: wl = hbar^2/(m_red a_c^2) = 41.80159/(M_red a_c^2)
#
# deuteron channel: wl_d = 41.80159/(1.207357 a_c^2) = 34.6224/a_c^2
# neutron channel:  wl_n = 41.80159/(0.805597 a_c^2) = 51.8889/a_c^2
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
tau ~  dt(0, pow(5,-2), 1)T(0,)
e1 ~  dnorm(0,0.1)T(0,)
ex <- e1
rf ~  dnorm(5,pow(0.1,-2))T(0,)
ri ~  dnorm(6,pow(0.1,-2))T(0,)
gin ~  dnorm(0,pow(0.5,-2))T(0,)
gout ~ dnorm(0,pow(0.5,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
adapt = 15000,
method="rjags",
monitor = c("e1","ex", "gin", "gout","ue","tau", "ri","rf","RSS","mux0","mux1","mux2","scale"),
model  = Model,
thin = 50,
n.chains = 4,
burnin = 15000,
sample = 30000)
Normfit <- jags(data = model.data,
inits = inits,
method="rjags",
monitor = c("e1","ex", "gin", "gout","ue","tau", "ri","rf","RSS","mux0","mux1","mux2","scale"),
model  = Model,
thin = 50,
n.chains = 4,
burnin = 15000,
sample = 30000)
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("e1","ex", "gin", "gout","ue","tau", "ri","rf","RSS","mux0","mux1","mux2","scale"),
model  = Model,
thin = 50,
n.chains = 4,
burnin = 1500,
sample = 3000)
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("e1","ex", "gin", "gout","ue","tau", "ri","rf","RSS","mux0","mux1","mux2","scale"),
model  = Model,
n.thin = 1,
n.chains = 3,
n.burnin = 20000,
n.iter = 40000)
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("e1","ex", "gin", "gout","ue","tau", "ri","rf","RSS","mux0","mux1","mux2","scale"),
model  = textConnection(Model),
n.thin = 1,
n.chains = 3,
n.burnin = 20000,
n.iter = 40000)
jagsresults(x = Normfit , params = c("e1","ex", "gin", "gout","scale","tau","ri","rf"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
traplot(Normfit  ,c("e1","ex", "gin", "gout"),style="plain")
