min = c(0.001, 0.001, max = c(5, 5),
popSize = 50, maxiter = 100)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001), max = c(5, 5),
popSize = 50, maxiter = 100)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001), max = c(5, 5),
popSize = 50, maxiter = 100)
summary(GA)
plot(GA)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001), max = c(5, 5),
popSize = 50, maxiter = 500)
summary(GA)
summary(GA)
plot(GA)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.0001, 0.0001), max = c(10, 10),
popSize = 100, maxiter = 1000)
summary(GA)
plot(GA)
summary(GA)
plot(GA)
filled.contour(x1, x2, z, color.palette = jet.colors)
filled.contour(x1, x2, z, color.palette = terrain.colors)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 200)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 100)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 100,key.axes=F)
levelplot(z~x1*x2, grid, cuts = 100)
require(lattice)
levelplot(z~x1*x2, grid, cuts = 100)
levelplot(z~x1*x2,  cuts = 100)
levelplot(z~x1*x2,  cuts = 100,color.palette = terrain.colors)
levelplot(z~x1*x2,  cuts = 100,color.palette = terrain.colors,region = TRUE)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 100)
filled.contour(x1, x2, z,nlevels = 100)
library(RColorBrewer)
darkcols <- brewer.pal(8, "Dark2")
filled.contour(x1, x2, z,color.palette=darkcols, nlevels = 100)
filled.contour(x1, x2, z, color.palette = darkcols ,nlevels = 100)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 100)
terrain.colors
filled.contour(x1, x2, z, color.palette=colorRampPalette(c('white','blue','yellow','red','darkred')),nlevels = 100)
15*30
15*40
14+24
38*10
2*3/2+1
1+1
2*3
exp(0.1)
log(1.10\)
log(1.10)
0.1*1e6
1e5/1e3
500000/43
cite("fields")
cite("fields",bib = T)
cite("fields",bib)
citation("fields",bib)
citation("fields")
0.24742-0.24709
0.24709-0.24676
0.00033/2
2.532-2.460
2.460-2.386
1.127-1.074
1.074-1.023
6.105-5.627
5.627-5.123
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/He3dp/Real_data")
# 3Hedp analysis
#
# purpose: Real  DATA
#
# - 5 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorHe3dp(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
######################################################################
# preparation: remove all variables from the work space
#rm(list=ls())
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(MCMCvis);require(ggridges);require(cowplot)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
source("plot_Sfactor.R")
source("plot_normfactors.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
## Read DATA
ensamble <- read.csv("ensamble.csv",header = T) %>%
mutate(Syst=replace(Syst,Syst==0.06,0.078))  %>% filter(E <= 0.5)
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
ik <- as.numeric(ensamble$invK)
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
# Literature
#  0.35779   # resonance energy
#  1.0085    # reduced width incoming
#  0.025425   # reduced width outgoing
N <- nrow(ensamble)
obsy <- ensamble$S    # Response variable
obsx <-  ensamble$E   # Predictors
erry <- ensamble$Stat
set <- ensamble$dat
lab <- ensamble$invK
syst = c(0.03,unique(ensamble$Syst))
#syst <- syst[-3]
M <- 500
xx <- seq(min(obsx),max(obsx),length.out = M)
model.data <- list(obsy = obsy,    # Response variable
obsy2 = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble), # Sample size
syst = syst,
Nre = Nre,
re = re,
Nik = Nik,
ik  = ik,
M = M,
xx = xx
#                  ap  = 5,
#                  ad = 6
)
# Conservative case
######################################################################
Model <- "model{
# LIKELIHOOD informative
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], E0, Er, gd2, gp2, ad, ap, ue[ik[i]]), pow(tau, -2))
}
# Residuals
for (i in 1:N) {
yy[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], E0, Er, gd2, gp2, ad, ap, ue[ik[i]]), pow(tau, -2))
res[i] <- obsy[i]-yy[i]
#res[i] <- obsy[i]-sfactor3Hedp(obsx[i], E0, Er, gd2, gp2, ad, ap,0)
nres[i] <- res[i]/obsy[i]
}
# LIKELIHOOD broad
for (i in 1:N) {
obsy2[i] ~ dnorm(y_2[i], pow(erry[i], -2))
y_2[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i],  E0_b, Er_b, gd2_b, gp2_b, ad_b, ap_b, ue[ik[i]]),pow(tau_2, -2))
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,0)
mux0_2[j] <- sfactor3Hedp(xx[j], E0_b, Er_b, gd2_b, gp2_b, ad_b, ap_b,0)
DeltaM[j] <- mux0[j]/mux0_2[j]
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,pow(0.1,-2))T(0,)
}
# PRIORS
# Case I
tau ~  dnorm(0, pow(1,-2))T(0,)
E0  ~  dnorm(0, pow(1,-2))T(0,)
Er <-  E0
gd2 ~  dnorm(0, pow(3,-2))T(0,)
gp2 ~  dnorm(0, pow(3,-2))T(0,)
ad  ~  dnorm(6, pow(0.01,-2))T(0,)
ap  ~  dnorm(5, pow(0.01,-2))T(0,)
# Case II
tau_2  ~  dnorm(0, pow(1,-2))T(0,)
Er_b  ~   dbeta(0.5,0.5)
E0_b  ~   dbeta(2,5)
gp2_b ~  dnorm(0, pow(3,-2))T(0,)
gd2_b  ~ dnorm(0, pow(3,-2))T(0,)
ad_b  ~  dunif(2,10)
ap_b  ~  dunif(2,10)
ue_ev[1] <-1e6*ue[1]
ue_ev[2] <-1e6*ue[2]
S_0   <- sfactor3Hedp(1e-4, E0, Er, gd2, gp2, ad, ap,0)
S_0b  <- sfactor3Hedp(1e-4, E0_b, Er_b, gd2_b, gp2_b, ad_b, ap_b,0)
}"
inits <- function(){ list(E0 = runif(1,0.3,0.35),E0_b = 0.4,Er_b = 0.4,gd2 = 1,
gp2 = runif(1,0.01,0.1),gd2_b = 0.5) }
set.seed(24)
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("Er","E0","gd2", "gp2","ue_ev","tau", "ad","ap",
"RSS","mux0","mux1","mux2","scale","DeltaM","S_0",
"S_0b","E0_b","Er_b","gd2_b",
"gp2_b","tau_2","ad_b","ap_b","res","nres"),
model.file  = textConnection(Model),
n.thin = 30,
n.chains = 5,
n.burnin = 75,
n.iter = 150)
# 3Hedp analysis
#
# purpose: Real  DATA
#
# - 5 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorHe3dp(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
######################################################################
# preparation: remove all variables from the work space
#rm(list=ls())
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(MCMCvis);require(ggridges);require(cowplot)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
source("plot_Sfactor.R")
source("plot_normfactors.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
## Read DATA
ensamble <- read.csv("ensamble.csv",header = T) %>%
mutate(Syst=replace(Syst,Syst==0.06,0.078))  %>% filter(E <= 0.5)
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
ik <- as.numeric(ensamble$invK)
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
# Literature
#  0.35779   # resonance energy
#  1.0085    # reduced width incoming
#  0.025425   # reduced width outgoing
N <- nrow(ensamble)
obsy <- ensamble$S    # Response variable
obsx <-  ensamble$E   # Predictors
erry <- ensamble$Stat
set <- ensamble$dat
lab <- ensamble$invK
syst = c(0.03,unique(ensamble$Syst))
#syst <- syst[-3]
M <- 500
xx <- seq(min(obsx),max(obsx),length.out = M)
model.data <- list(obsy = obsy,    # Response variable
obsy2 = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble), # Sample size
syst = syst,
Nre = Nre,
re = re,
Nik = Nik,
ik  = ik,
M = M,
xx = xx
#                  ap  = 5,
#                  ad = 6
)
# Conservative case
######################################################################
Model <- "model{
# LIKELIHOOD informative
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], E0, Er, gd2, gp2, ad, ap, ue[ik[i]]), pow(tau, -2))
}
# Residuals
for (i in 1:N) {
yy[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], E0, Er, gd2, gp2, ad, ap, ue[ik[i]]), pow(tau, -2))
res[i] <- obsy[i]-yy[i]
#res[i] <- obsy[i]-sfactor3Hedp(obsx[i], E0, Er, gd2, gp2, ad, ap,0)
nres[i] <- res[i]/obsy[i]
}
# LIKELIHOOD broad
for (i in 1:N) {
obsy2[i] ~ dnorm(y_2[i], pow(erry[i], -2))
y_2[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i],  E0_b, Er_b, gd2_b, gp2_b, ad_b, ap_b, ue[ik[i]]),pow(tau_2, -2))
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,0)
mux0_2[j] <- sfactor3Hedp(xx[j], E0_b, Er_b, gd2_b, gp2_b, ad_b, ap_b,0)
DeltaM[j] <- mux0[j]/mux0_2[j]
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,pow(0.1,-2))T(0,)
}
# PRIORS
# Case I
tau ~  dnorm(0, pow(1,-2))T(0,)
E0  ~  dnorm(0, pow(1,-2))T(0,)
Er <-  E0
gd2 ~  dnorm(0, pow(3,-2))T(0,)
gp2 ~  dnorm(0, pow(3,-2))T(0,)
ad  ~  dnorm(6, pow(0.01,-2))T(0,)
ap  ~  dnorm(5, pow(0.01,-2))T(0,)
# Case II
tau_2  ~  dnorm(0, pow(1,-2))T(0,)
Er_b  ~   dbeta(0.5,0.5)
E0_b  ~   dbeta(2,5)
gp2_b ~  dnorm(0, pow(3,-2))T(0,)
gd2_b  ~ dnorm(0, pow(3,-2))T(0,)
ad_b  ~  dunif(2,10)
ap_b  ~  dunif(2,10)
ue_ev[1] <-1e6*ue[1]
ue_ev[2] <-1e6*ue[2]
S_0   <- sfactor3Hedp(1e-4, E0, Er, gd2, gp2, ad, ap,0)
S_0b  <- sfactor3Hedp(1e-4, E0_b, Er_b, gd2_b, gp2_b, ad_b, ap_b,0)
}"
inits <- function(){ list(E0 = runif(1,0.3,0.35),E0_b = 0.4,Er_b = 0.4,gd2 = 1,
gp2 = runif(1,0.01,0.1),gd2_b = 0.5) }
set.seed(24)
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("Er","E0","gd2", "gp2","ue_ev","tau", "ad","ap",
"RSS","mux0","mux1","mux2","scale","DeltaM","S_0",
"S_0b","E0_b","Er_b","gd2_b",
"gp2_b","tau_2","ad_b","ap_b","res","nres"),
model.file  = textConnection(Model),
n.thin = 30,
n.chains = 5,
n.burnin = 75,
n.iter = 150)
Normfit
str(Normfit)
traplot(Normfit  ,c("E0","gd2", "gp2","ue"),style="plain")
xx < rnorm(1000,4,2)
xx < -rnorm(1000,4,2)
xx <- norm(1000,4,2)
xx <- rnorm(1000,4,2)
plot(xx)
plot(xx,type="l")
xx
plot(xx,type="l")
######################################################################
## Read DATA
ensamble <- read.csv("ensamble_Tdn_extra.csv",header = T) %>%  filter(E <= 0.3)
#filter(dat!= "Mag75")
#%>% filter(E <= 0.5) %>%   filter(dat!= "Arn53") %>%
# droplevels(ensamble$dat)
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
N <- nrow(ensamble)
obsy <- ensamble$S    # Response variable
obsx <-  ensamble$E   # Predictors
erry <- ensamble$Stat
set <- ensamble$dat
lab <- ensamble$invK
syst = c(unique(ensamble$Syst))
i = seq(1:N)
likelihood <- function(par){
e1 = par[1]
gin = par[2]
gout = par[3]
sigmax = par[4]
scale = par[5:9]
#  y = par[10:133]
llscale = sum(dlnorm(scale,meanlog = log(1), sdlog = log(1 + syst^2), log = T))
lly <- sum(dnorm(obsy,scale[re]*sfactorTdn_5p(obsx, e1,gin, gout,6,5), sd = sigmax,  log = T))
return(llscale   + lly)
}
setup <- createBayesianSetup(likelihood = likelihood,
lower = c(0.001,0.001,0.001,0.001,rep(0.5,5)),
upper = c(1,2,2,5,rep(1.5,5)))
settings <- list(iterations = 100000,adaptation=5000,
burnin = 20000, message=T)
res <- runMCMC(bayesianSetup = setup, settings = settings,sampler = "DREAMzs")
summary(res)
tracePlot(sampler = res, thin = 20, start = 5000, whichParameters = c(1,2,3))
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/Tdn/Real_data")
######################################################################
## Read DATA
ensamble <- read.csv("ensamble_Tdn_extra.csv",header = T) %>%  filter(E <= 0.3)
#filter(dat!= "Mag75")
#%>% filter(E <= 0.5) %>%   filter(dat!= "Arn53") %>%
# droplevels(ensamble$dat)
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
N <- nrow(ensamble)
obsy <- ensamble$S    # Response variable
obsx <-  ensamble$E   # Predictors
erry <- ensamble$Stat
set <- ensamble$dat
lab <- ensamble$invK
syst = c(unique(ensamble$Syst))
i = seq(1:N)
likelihood <- function(par){
e1 = par[1]
gin = par[2]
gout = par[3]
sigmax = par[4]
scale = par[5:9]
#  y = par[10:133]
llscale = sum(dlnorm(scale,meanlog = log(1), sdlog = log(1 + syst^2), log = T))
lly <- sum(dnorm(obsy,scale[re]*sfactorTdn_5p(obsx, e1,gin, gout,6,5), sd = sigmax,  log = T))
return(llscale   + lly)
}
setup <- createBayesianSetup(likelihood = likelihood,
lower = c(0.001,0.001,0.001,0.001,rep(0.5,5)),
upper = c(1,2,2,5,rep(1.5,5)))
settings <- list(iterations = 100000,adaptation=5000,
burnin = 20000, message=T)
res <- runMCMC(bayesianSetup = setup, settings = settings,sampler = "DREAMzs")
summary(res)
tracePlot(sampler = res, thin = 20, start = 5000, whichParameters = c(1,2,3))
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/Tdn/Real_data")
######################################################################
# import packages
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);
library(dplyr);library(BayesianTools)
## for block updating [we do not need to center predictor variables]
######################################################################
## Read DATA
ensamble <- read.csv("ensamble_Tdn_extra.csv",header = T) %>%  filter(E <= 0.3)
#filter(dat!= "Mag75")
#%>% filter(E <= 0.5) %>%   filter(dat!= "Arn53") %>%
# droplevels(ensamble$dat)
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
N <- nrow(ensamble)
obsy <- ensamble$S    # Response variable
obsx <-  ensamble$E   # Predictors
erry <- ensamble$Stat
set <- ensamble$dat
lab <- ensamble$invK
syst = c(unique(ensamble$Syst))
i = seq(1:N)
likelihood <- function(par){
e1 = par[1]
gin = par[2]
gout = par[3]
sigmax = par[4]
scale = par[5:9]
#  y = par[10:133]
llscale = sum(dlnorm(scale,meanlog = log(1), sdlog = log(1 + syst^2), log = T))
lly <- sum(dnorm(obsy,scale[re]*sfactorTdn_5p(obsx, e1,gin, gout,6,5), sd = sigmax,  log = T))
return(llscale   + lly)
}
setup <- createBayesianSetup(likelihood = likelihood,
lower = c(0.001,0.001,0.001,0.001,rep(0.5,5)),
upper = c(1,2,2,5,rep(1.5,5)))
settings <- list(iterations = 100000,adaptation=5000,
burnin = 20000, message=T)
res <- runMCMC(bayesianSetup = setup, settings = settings,sampler = "DREAMzs")
summary(res)
tracePlot(sampler = res, thin = 20, start = 5000, whichParameters = c(1,2,3))
tracePlot(sampler = res, thin = 20, start = 10000, whichParameters = c(1,2,3))
