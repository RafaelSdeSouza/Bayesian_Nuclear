rf ~ dunif(2,8)
tau ~  dgamma(0.01,0.01)
e1 ~   dunif(0,10)
gin ~ dgamma(0.01,0.01)
gout ~ dgamma(0.01,0.01)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.15,1),gin=runif(1,1,5),gout=runif(1,0.01,1)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout","tau","mux","yx","scale","ri","rf"),
model = textConnection(Model),
n.thin = 10,
n.chains = 10,
n.burnin = 2000,
n.iter = 4000)
# 3Hedp analysis
#
# purpose: Real  DATA
#
# - 3 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorTdn_fast(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
######################################################################
# preparation: remove all variables from the work space
rm(list=ls())
set.seed(123)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr)
library(dplyr);require(ggsci)
source("https://raw.githubusercontent.com/johnbaums/jagstools/master/R/jagsresults.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
## Read DATA GENERATION
#ensamble <- read.csv("ensamble.csv",header = T,stringsAsFactors=FALSE)  %>%
#  mutate(Stat=replace(Stat,Stat==0,0.1)) %>%
#  mutate(dat=replace(dat,dat %in% c("gei99b","gei99d"),"Gei99")) %>%
#  mutate(dat=replace(dat,dat %in% c("Kra87m","Kra87b"),"Kra87")) %>%
#  mutate(dat=replace(dat,dat == "zhi77b","Zhi77")) %>%
# filter(.,dat!="Lac05")  %>% droplevels(.) %>%
# mutate(dat=as.factor(dat))
ensamble <- read.csv("ensamble_Tdn.csv",header = T)
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
# Radius
# r_i = 6
# r_f = 5
# Literature
#  0.35779   # resonance energy
#  1.0085    # reduced width incoming
#  0.025425   # reduced width outgoing
N <- nrow(ensamble)
obsy <- ensamble$S    # Response variable
obsx <-  ensamble$E   # Predictors
erry <- ensamble$Stat
set <- ensamble$dat
syst = unique(ensamble$Syst)
#syst <- syst[-3]
M <- 500
xx <- exp(seq(log(min(obsx)),log(max(obsx)),length.out = M))
model.data <- list(obsy = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble), # Sample size
syst = syst,
Nre = Nre,
re = re,
M = M,
xx = xx
)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactorTdn(obsx[i], e1, gin, gout, ri, rf,0),pow(tau, -2))
}
# Predicted values
for (j in 1:M){
mux[j] <- sfactorTdn(xx[j], e1, gin, gout, ri, rf,0)
yx[j] ~ dnorm(mux[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),pow(log(1+syst[k]),-2))
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
ri ~ dunif(2,8)
rf ~ dunif(2,8)
tau ~  dgamma(0.01,0.01)
e1 ~   dunif(0,10)
gin ~ dgamma(0.01,0.01)
gout ~ dgamma(0.01,0.01)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.15,1),gin=runif(1,1,5),gout=runif(1,0.01,1)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout","tau","mux","yx","scale","ri","rf"),
model = textConnection(Model),
n.thin = 10,
n.chains = 10,
n.burnin = 2000,
n.iter = 4000)
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/Tdn/Real_data")
######################################################################
# Author: Christian Iliadis (09/26/2017)
#
# MCMCsfactorTdn_gauss.R
#
# purpose: analyzing real Tdn data
#
# six parameters are assumed: Er, gamma_i^2, gamma_f^2, R_i, R_f, U_e
# [e1, gin, gout, rin, rout, ue]
#
# uses the C++ function sfactorTdn(E, Er, gin, gout, rin, rout, ue),
# which calls gsl libraries to compute Coulomb wave functions;
#
# the function "Sfactor" in this script is used only for plotting
# believable S-factors
#
# MAKE SURE YOU ARE USING THE SAME VALUES FOR MASSES, ENERGIES, ETC.,
# IN BOTH THIS SCRIPT (FUNCTION Sfactor) AND THE C++ SFACTOR FUNCTION
# IN JAGS (sfactorTdn.cc)
#
# uses:
# - normal likelihoods
# - systematic uncertainties
# - intrinsic scatter
#
######################################################################
# preparation: remove all variables from the work space
rm(list=ls())
# import jags package
library(rjags)
## for block updating [we do not need to center predictor variables]
require(gsl)
require(RcppGSL)
load.module("nuclear")
load.module("glm")
#set.seed(123)
######################################################################
######################################################################
## FUNCTIONS
######################################################################
######################################################################
# error bars
# w is the width of perpendicular end bars on errors; set to zero
add.error.bars <- function(X,Y,dX,dY,w,col){
X0 = X
Y0 = (Y-dY)
X1 =X
Y1 = (Y+dY)
arrows(X0, Y0, X1, Y1, lwd=2, code=3, angle=90, length=w, col=col)
Y0 = Y
X0 = (X-dX)
Y1 =Y
X1 = (X+dX)
arrows(X0, Y0, X1, Y1, lwd=2, code=3, angle=90, length=w, col=col)
}
######################################################################
# compute S-factor using gsl Coulomb wave functions for plotting
# purposes only
#
# ECM   :   energy
# ER    :   formal resonance energy
# gi, gf:   reduced widths for incoming/outgoing channels
# ri, rf:   channel radii (fm) for incoming/outgoing channels
# ue    :   laboratory electron screening potential
Sfactor <- function(ECM,ER,gi,gf,ri,rf,ue){
# input masses, charges, angular momenta
m1_i = 3.01550
m2_i = 2.01355        # masses (amu) of t and d
m1_f = 4.00151
m2_f = 1.008664       # masses (amu) of n and 4He
z1_i = 1
z2_i = 1              # charges of t and d
z1_f = 2
z2_f = 0				# charges of n and 4He
jt=0.5                # spins of target, projectile, resonance
jp=1.0
jr=1.5
Q = 17.589293			# reaction Q-value (MeV)
la = 0
lb = 2				# orbital angular momenta of d and n
# reduced masses
mue_i <- (m1_i*m2_i)/(m1_i+m2_i)
mue_f <- (m1_f*m2_f)/(m1_f+m2_f)
# constants
pek <- 6.56618216e-1/mue_i
omega <- (2*jr+1)/((2*jt+1)*(2*jp+1))
# penetration and shift factors at resonance energy
eta_a=0.1574854*z2_i*z1_i*sqrt(mue_i)
rho_a=0.218735*ri*sqrt(mue_i)
reta_i=eta_a/(sqrt(ER))
rrho_i=rho_a*(sqrt(ER))
P1 <- coulomb_wave_FG(reta_i, rrho_i, la, k=0)
pr_i <- rrho_i/(P1$val_F^2 + P1$val_G^2)
sr_i <- rrho_i*(P1$val_F*P1$val_Fp + P1$val_G*P1$val_Gp)/(P1$val_F^2 + P1$val_G^2)
# partial width of incoming channel
ga <- 2*gi*pr_i
eta_b=0.1574854*z2_f*z1_f*sqrt(mue_f)
rho_b=0.218735*rf*sqrt(mue_f)
reta_f=eta_b/(sqrt(ER+Q))
rrho_f=rho_b*(sqrt(ER+Q))
P2 <- coulomb_wave_FG(reta_f, rrho_f, lb, k=0)
pr_f <- rrho_f/(P2$val_F^2 + P2$val_G^2)
sr_f <- rrho_f*(P2$val_F*P2$val_Fp + P2$val_G*P2$val_Gp)/(P2$val_F^2 + P2$val_G^2)
# partial width of outgoing channel
gb <- 2*gf*pr_f
# calculate S-factor; penetration and shift factors computed at
# energy ECM
etpe_i=exp(0.98951013*z1_i*z2_i*sqrt(mue_i/ECM))
eta_i=eta_a/(sqrt(ECM))
rho_i=rho_a*(sqrt(ECM))
P3 <- coulomb_wave_FG(eta_i, rho_i, la, k=0)
p_i <- rho_i/(P3$val_F^2 + P3$val_G^2)
s_i <- rho_i*(P3$val_F*P3$val_Fp + P3$val_G*P3$val_Gp)/(P3$val_F^2 + P3$val_G^2)
prat_i=p_i/pr_i
eta_f=eta_b/(sqrt(ECM+Q))
rho_f=rho_b*(sqrt(ECM+Q))
P4 <- coulomb_wave_FG(eta_f, rho_f, lb, k=0)
p_f <- rho_f/(P4$val_F^2 + P4$val_G^2)
s_f <- rho_f*(P4$val_F*P4$val_Fp + P4$val_G*P4$val_Gp)/(P4$val_F^2 + P4$val_G^2)
prat_f=p_f/pr_f
tapp <- (s_i-sr_i)*gi+(s_f-sr_f)*gf
s1=pek*etpe_i*omega*prat_i*prat_f*ga*gb
s2=((ER-ECM-tapp)^2)+0.25*((ga*prat_i+gb*prat_f)^2)
SF <- exp( 0.5*0.98951013e0*z1_i*z2_i*sqrt(mue_i)*ue*ECM^(-1.5) )*s1/s2
return(SF = SF)
}
######################################################################
GammaTdn <- function(ER,gi,gf,ri,rf){
# input masses, charges, angular momenta
m1_i = 3.01550
m2_i = 2.01355        # masses (amu) of t and d
m1_f = 4.00151
m2_f = 1.008664       # masses (amu) of n and 4He
z1_i = 1
z2_i = 1              # charges of t and d
z1_f = 2
z2_f = 0				# charges of n and 4He
jt=0.5                # spins of target, projectile, resonance
jp=1.0
jr=1.5
Q = 17.589293			# reaction Q-value (MeV)
la = 0
lb = 2				# orbital angular momenta of d and n
# reduced masses
mue_i <- (m1_i*m2_i)/(m1_i+m2_i)
mue_f <- (m1_f*m2_f)/(m1_f+m2_f)
# constants
pek <- 6.56618216e-1/mue_i
omega <- (2*jr+1)/((2*jt+1)*(2*jp+1))
# penetration and shift factors at resonance energy
eta_a=0.1574854*z2_i*z1_i*sqrt(mue_i)
rho_a=0.218735*ri*sqrt(mue_i)
reta_i=eta_a/(sqrt(ER))
rrho_i=rho_a*(sqrt(ER))
P1 <- coulomb_wave_FG(reta_i, rrho_i, la, k=0)
pr_i <- rrho_i/(P1$val_F^2 + P1$val_G^2)
sr_i <- rrho_i*(P1$val_F*P1$val_Fp + P1$val_G*P1$val_Gp)/(P1$val_F^2 + P1$val_G^2)
# partial width of incoming channel
ga <- 2*gi*pr_i
eta_b=0.1574854*z2_f*z1_f*sqrt(mue_f)
rho_b=0.218735*rf*sqrt(mue_f)
reta_f=eta_b/(sqrt(ER+Q))
rrho_f=rho_b*(sqrt(ER+Q))
P2 <- coulomb_wave_FG(reta_f, rrho_f, lb, k=0)
pr_f <- rrho_f/(P2$val_F^2 + P2$val_G^2)
sr_f <- rrho_f*(P2$val_F*P2$val_Fp + P2$val_G*P2$val_Gp)/(P2$val_F^2 + P2$val_G^2)
# partial width of outgoing channel
gb <- 2*gf*pr_f
return(list(Ga = ga, Gb = gb))
}
######################################################################
######################################################################
## DATA INPUT
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# Barker values:
# Er  = 0.0912 MeV
# g^2_in = 2.93 MeV         ! reduced width of deuteron
# g^2_out = 0.0794 MeV      ! reduced width of neutron
# rin = 6.0 fm
# rout = 5.0 fm
#
# energy is in units of MeV, and the S-factor in MeVb;
## DATA SETS
tab1 <- read.table("data_jarmie.dat", header=FALSE)
obsx1 <- c(tab1[,1])
obsy1 <- c(tab1[,2])
errobsy1 <- c(tab1[,3])
tab2 <- read.table("data_brown.dat", header=FALSE)
obsx2 <- c(tab2[,1])
obsy2 <- c(tab2[,2])
errobsy2 <- c(tab2[,3])
tab3 <- read.table("data_kobzev.dat", header=FALSE)
obsx3 <- c(tab3[,1])
obsy3 <- c(tab3[,2])
errobsy3 <- c(tab3[,3])
tab4 <- read.table("data_arnold.dat", header=FALSE)
obsx4 <- c(tab4[,1])
obsy4 <- c(tab4[,2])
errobsy4 <- c(tab4[,3])
######################################################################
# rjags
######################################################################
cat('model {
# LIKELIHOOD
# systematic error as normalization factor n.norm...
# ue is the electron screening potential for normal kinematics
for (i in 1:length(obsx1)) {
# measured number of decays including exp stat uncertainties
obsy1[i] ~ dnorm(ym1[i], pow(errobsy1[i], -2))
# measured number of decays including exp syst uncertainties
ym1[i] <- n.norm1 * ya1[i]
# actual number of decays subject to stat fluctuations
ya1[i] ~ dnorm(yt1[i], pow(intrscat, -2))
# true number of decays
yt1[i] <- sfactorTdn(obsx1[i], e1, gin, gout, rin, rout, ue)
}
for (i in 1:length(obsx2)) {
# measured number of decays including exp stat uncertainties
obsy2[i] ~ dnorm(ym2[i], pow(errobsy2[i], -2))
# measured number of decays including exp syst uncertainties
ym2[i] <- n.norm2 * ya2[i]
# actual number of decays subject to stat fluctuations
ya2[i] ~ dnorm(yt2[i], pow(intrscat, -2))
# true number of decays
yt2[i] <- sfactorTdn(obsx2[i], e1, gin, gout, rin, rout, ue)
}
for (i in 1:length(obsx3)) {
# measured number of decays including exp stat uncertainties
obsy3[i] ~ dnorm(ym3[i], pow(errobsy3[i], -2))
# measured number of decays including exp syst uncertainties
ym3[i] <- n.norm3 * ya3[i]
# actual number of decays subject to stat fluctuations
ya3[i] ~ dnorm(yt3[i], pow(intrscat, -2))
# true number of decays
yt3[i] <- sfactorTdn(obsx3[i], e1, gin, gout, rin, rout, ue)
}
for (i in 1:length(obsx4)) {
# measured number of decays including exp stat uncertainties
obsy4[i] ~ dnorm(ym4[i], pow(errobsy4[i], -2))
# measured number of decays including exp syst uncertainties
ym4[i] <- n.norm4 * ya4[i]
# actual number of decays subject to stat fluctuations
ya4[i] ~ dnorm(yt4[i], pow(intrscat, -2))
# true number of decays
yt4[i] <- sfactorTdn(obsx4[i], e1, gin, gout, rin, rout, ue)
}
# PRIORS
# e1, gin, gout are the resonance energy, initial reduced width,
# final reduced width [gin = gamma^2]
## priors:
#
# Wigner limit: wl = hbar^2/(m_red a_c^2) = 41.80159/(M_red a_c^2)
#
# deuteron channel: wl_d = 41.80159/(1.207357 a_c^2) = 34.6224/a_c^2
# neutron channel:  wl_n = 41.80159/(0.805597 a_c^2) = 51.8889/a_c^2
wl_d <- 34.6224*pow(rin, -2)
wl_n <- 51.8889*pow(rout, -2)
#
#  e1 ~ dunif(0, 10)                 # postive since we see sigma peak
e1 ~ dnorm(0.0, pow(0.1, -2))T(0,)
gin ~ dunif(0.0, 10*wl_d)          # x times Wigner limit
gout ~ dunif(0.0, 10*wl_n)         # x times Wigner limit
intrscat ~ dunif(0, 5)             # certainly less than 5 MeVb
rin <- 6.0
rout <- 5.0
#  ue ~ dunif(0, 0.01)               # certainly less than 10 keV
ue <- 0.0
#  rin ~ dnorm(5.5, pow(1.0, -2))T(0,)
#  rout ~ dnorm(5.5, pow(1.0, -2))T(0,)
#  ue ~ dunif(0, 0.1)
#  gin ~ dnorm(0.0, pow(10, -2))T(0,)
#  gout ~ dnorm(0.0, pow(10, -2))T(0,)
#  rin ~ dnorm(5.5, pow(1.0, -2))T(0,)
#  rout ~ dnorm(5.5, pow(1.0, -2))T(0,)
#  rin ~ dunif(3.5, 7.5)
#  rout ~ dunif(3.5, 7.5)
#  ue ~ dunif(0, 0.01)
## uniform priors:
#  e1 ~ dunif(0.0, 10.0)
#  gin ~ dunif(gout, 10.0)
#  gout ~ dunif(0.0, 10.0)
# gamma priors
#  e1 ~ dunif(0.0, 10.0)
#  gin ~ dgamma(0.5,100)
#  gout ~ dgamma(0.5,100)
#  gin ~ dgamma(0.5,rl1)
#  gout ~ dgamma(0.5,rl2)
#  rl1 ~ dunif(0,500)
#  rl2 ~ dunif(0,500)
#  gin ~ dchisqr(1)T(gout,)
#  gin ~ dchisqr(1)
#  gout ~ dchisqr(1)
## or hyperprior:
#  e1 ~ dunif(0.01, 1.0)
#  gin ~ dgamma(s1, r1)
#  gout ~ dgamma(s2, r2)
#  s1 ~ dunif(0.1, 1.0)
#  s2 ~ dunif(0.1, 1.0)
#  r1 ~ dunif(1.0e-6, 1.0)
#  r2 ~ dunif(1.0e-6, 1.0)
# systematic errors as normalization factors
### lognormal density:
# log(): natural logarithm
n.norm1 ~ dlnorm(logmu1, pow(logsigma1, -2))
logmu1 <- log(1.0)       # median of factor uncertainty is 1.0
logsigma1 <- log(1.0126) # factor uncertainty is 1.0126, i.e. 1.26% for Jar84
n.norm2 ~ dlnorm(logmu2, pow(logsigma2, -2))
logmu2 <- log(1.0)       # median of factor uncertainty is 1.0
logsigma2 <- log(100.0)  # factor uncertainty very large since Bro87 used
# the normalization of Jar84
n.norm3 ~ dlnorm(logmu3, pow(logsigma3, -2))
logmu3 <- log(1.0)       # median of factor uncertainty is 1.0
logsigma3 <- log(1.025)  # factor uncertainty is 1.025, i.e., 2.5% for Kob66
n.norm4 ~ dlnorm(logmu4, pow(logsigma4, -2))
logmu4 <- log(1.0)       # median of factor uncertainty is 1.0
logsigma4 <- log(1.020)  # factor uncertainty is 1.020, i.e., 2.0% for Arn53
}', file={f <- tempfile()})
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
n.adapt  <- 500
n.update <- 1000
n.iter   <- 5000
n.chains <- 3
n.thin   <- 1
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model;
#
ourmodel <- jags.model(f, data = list('obsx1' = obsx1, ## jags wants all data in a list
'obsy1' = obsy1,
'errobsy1' = errobsy1,
'obsx2' = obsx2,
'obsy2' = obsy2,
'errobsy2' = errobsy2,
'obsx3' = obsx3,
'obsy3' = obsy3,
'errobsy3' = errobsy3,
'obsx4' = obsx4,
'obsy4' = obsy4,
'errobsy4' = errobsy4),
#    inits = list(e1 = 0.40, gin = 1.9, gout = 0.05, rin = 6.0, rout = 5.5),
n.chains = n.chains,
n.adapt = n.adapt)
# burnin
update(ourmodel, n.update, progress.bar="none")
mcmcChain <- coda.samples(ourmodel,
variable.names=c('e1', 'gin', 'gout', 'intrscat',
'n.norm1', 'n.norm2', 'n.norm3', 'n.norm4',
'rin', 'rout','ue'),
n.iter=n.iter, n.thin=n.thin)
cat("", "\n")    # output empty line
cat("SUMMARY:", "\n")
show(summary(mcmcChain, quantiles = c(0.025, 0.16, 0.5, 0.84, 0.975)))
cat("-------------------------------------------", "\n")
plot(mcmcChain)
