}
for (j in 1:M){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1,0.0912, gin, gout,6,5,0)
}
tau ~  dgamma(0.1,0.1)
e1 ~  dgamma(0.1,0.1)
gin ~  dgamma(0.1,0.1)
gout ~ dgamma(0.1,0.1)
})
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
mcmc.output <- nimbleMCMC(model, data = model.data, inits = inits,
monitors = c("e1", "gin", "gout","tau"), thin = 10,
niter = 20000, nburnin = 1000, nchains = 3,
summary = TRUE, WAIC = TRUE)
model <- nimbleCode({
for (i in 1:N) {
obsy[i] ~ dnorm(sfactorTdn(obsx[i], e1,0.0912, gin, gout,6,5,0),sd)
}
for (j in 1:M){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1,0.0912, gin, gout,6,5,0)
}
sd ~  dgamma(0.1,0.1)
e1 ~  dgamma(0.1,0.1)
gin ~  dgamma(0.1,0.1)
gout ~ dgamma(0.1,0.1)
})
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
mcmc.output <- nimbleMCMC(model, data = model.data, inits = inits,
monitors = c("e1", "gin", "gout","sd"), thin = 10,
niter = 20000, nburnin = 1000, nchains = 3,
summary = TRUE, WAIC = TRUE)
model <- nimbleCode({
for (i in 1:150) {
obsy[i] ~ dnorm(sfactorTdn(obsx[i], e1,0.0912, gin, gout,6,5,0),sd)
}
for (j in 1:150){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1,0.0912, gin, gout,6,5,0)
}
sd ~  dgamma(0.1,0.1)
e1 ~  dgamma(0.1,0.1)
gin ~  dgamma(0.1,0.1)
gout ~ dgamma(0.1,0.1)
})
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
mcmc.output <- nimbleMCMC(model, data = model.data, inits = inits,
monitors = c("e1", "gin", "gout","sd"), thin = 10,
niter = 20000, nburnin = 1000, nchains = 3,
summary = TRUE, WAIC = TRUE)
mcmc.output <- runMCMC(model, data = model.data, inits = inits,
monitors = c("e1", "gin", "gout","sd"), thin = 10,
niter = 20000, nburnin = 1000, nchains = 3,
summary = TRUE, WAIC = TRUE)
model.data
Rmodel <- nimbleModel(code)
Rmcmc <- buildMCMC(Rmodel)
Rmodel$setData(Rmodel$setData)
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
Rmodel$setData(model.data)
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
samplesList <- runMCMC(Cmcmc, niter = 10000, nchains = 3, inits = inits)
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/Tdn/Synthetic")
Sfactor3 <- function(ECM, E1, EX, gi, gf, ri, rf, ue){
# input masses, charges, angular momenta
m1_i = 3.01550
m2_i = 2.01355        # masses (amu) of t and d
m1_f = 4.00151
m2_f = 1.008664       # masses (amu) of n and 4He
z1_i = 1
z2_i = 1              # charges of t and d
z1_f = 2
z2_f = 0				# charges of n and 4He
jt=0.5                # spins of target, projectile, resonance
jp=1.0
jr=1.5
Q = 17.589293			# reaction Q-value (MeV)
la = 0
lb = 2				# orbital angular momenta of d and n
# reduced masses
mue_i <- (m1_i*m2_i)/(m1_i+m2_i)
mue_f <- (m1_f*m2_f)/(m1_f+m2_f)
# constants
pek <- 6.56618216e-1/mue_i
omega <- (2*jr+1)/((2*jt+1)*(2*jp+1))
### CALCULATE S-FACTOR
## incoming channel
etpe_i=exp(0.98951013*z1_i*z2_i*sqrt(mue_i/ECM))
eta_a=0.1574854*z2_i*z1_i*sqrt(mue_i)
rho_a=0.218735*ri*sqrt(mue_i)
eta_i=eta_a/(sqrt(ECM))
rho_i=rho_a*(sqrt(ECM))
P3 <- coulomb_wave_FG(eta_i, rho_i, la, k=0)
# penetration and shift factor
p_i <- rho_i/(P3$val_F^2 + P3$val_G^2)
s_i <- rho_i*(P3$val_F*P3$val_Fp + P3$val_G*P3$val_Gp)/(P3$val_F^2 + P3$val_G^2)
# shift factor at observed energy Ex
xeta_i=eta_a/(sqrt(EX))
xrho_i=rho_a*(sqrt(EX))
PX1 <- coulomb_wave_FG(xeta_i, xrho_i, la, k=0)
b_i <- xrho_i*(PX1$val_F*PX1$val_Fp + PX1$val_G*PX1$val_Gp)/(PX1$val_F^2 + PX1$val_G^2)
# partial width
Ga <- 2*gi*p_i
## outgoing channel
eta_b=0.1574854*z2_f*z1_f*sqrt(mue_f)
rho_b=0.218735*rf*sqrt(mue_f)
eta_f=eta_b/(sqrt(ECM+Q))
rho_f=rho_b*(sqrt(ECM+Q))
P4 <- coulomb_wave_FG(eta_f, rho_f, lb, k=0)
# penetration and shift factor
p_f <- rho_f/(P4$val_F^2 + P4$val_G^2)
s_f <- rho_f*(P4$val_F*P4$val_Fp + P4$val_G*P4$val_Gp)/(P4$val_F^2 + P4$val_G^2)
# shift factor at observed energy Ex+Q
xeta_f=eta_b/(sqrt(EX+Q))
xrho_f=rho_b*(sqrt(EX+Q))
PX2 <- coulomb_wave_FG(xeta_f, xrho_f, lb, k=0)
b_f <- xrho_f*(PX2$val_F*PX2$val_Fp + PX2$val_G*PX2$val_Gp)/(PX2$val_F^2 + PX2$val_G^2)
# partial width
Gb <- 2*gf*p_f
tapp <- (s_i-b_i)*gi+(s_f-b_f)*gf
s1=pek*etpe_i*omega*Ga*Gb
s2=((E1-ECM-tapp)^2)+0.25*((Ga+Gb)^2)
SF <- exp( 0.5*0.98951013e0*z1_i*z2_i*sqrt(mue_i)*ue*ECM^(-1.5) )*s1/s2
return(SF = SF)
}
######################################################################
GammaTdn <- function(E1,gi,gf,ri,rf){
# input masses, charges, angular momenta
m1_i = 3.01550
m2_i = 2.01355        # masses (amu) of t and d
m1_f = 4.00151
m2_f = 1.008664       # masses (amu) of n and 4He
z1_i = 1
z2_i = 1              # charges of t and d
z1_f = 2
z2_f = 0				# charges of n and 4He
jt=0.5                # spins of target, projectile, resonance
jp=1.0
jr=1.5
Q = 17.589293			# reaction Q-value (MeV)
la = 0
lb = 2				# orbital angular momenta of d and n
# reduced masses
mue_i <- (m1_i*m2_i)/(m1_i+m2_i)
mue_f <- (m1_f*m2_f)/(m1_f+m2_f)
# constants
pek <- 6.56618216e-1/mue_i
omega <- (2*jr+1)/((2*jt+1)*(2*jp+1))
# penetration and shift factors at resonance energy
eta_a=0.1574854*z2_i*z1_i*sqrt(mue_i)
rho_a=0.218735*ri*sqrt(mue_i)
reta_i=eta_a/(sqrt(E1))
rrho_i=rho_a*(sqrt(E1))
P1 <- coulomb_wave_FG(reta_i, rrho_i, la, k=0)
pr_i <- rrho_i/(P1$val_F^2 + P1$val_G^2)
# partial width of incoming channel
ga <- 2*gi*pr_i
eta_b=0.1574854*z2_f*z1_f*sqrt(mue_f)
rho_b=0.218735*rf*sqrt(mue_f)
reta_f=eta_b/(sqrt(E1+Q))
rrho_f=rho_b*(sqrt(E1+Q))
P2 <- coulomb_wave_FG(reta_f, rrho_f, lb, k=0)
pr_f <- rrho_f/(P2$val_F^2 + P2$val_G^2)
# partial width of outgoing channel
gb <- 2*gf*pr_f
return(list(Ga = ga, Gb = gb))
}
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(gsl);library(latex2exp)
require(runjags);require(gsl)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
## ARTIFICIAL DATA GENERATION
N <- 150
#obsx1 <- runif(N,0,0.7)
obsx1 <- exp(runif(N,log(1e-3),log(1)))
sd <- 0.1
obsy1 <- rnorm(N, Sfactor3(obsx1,0.0912,0.0912,2.93,0.0794,6,5,0),sd=sd)
M <- 150
xx <- seq(min(obsx1),max(obsx1),length.out = M)
model.data <- list(obsy = obsy1,    # Response variable
obsx =  obsx1,   # Predictors
#                   erry = errobsy1,
N = N, # Sample size
M = M,
xx = xx
)
#
sfactorTdn <- nimbleRcall(function(obsx1 = double(1),
e1 = double(1),ex = double(1),gin = double(1),
gout = double(1),ri = double(1),rf = double(1),ue = double(1)){}, Rfun = 'Sfactor3',
returnType = double(1), envir = .GlobalEnv)
model <- nimbleCode({
for (i in 1:150) {
obsy[i] ~ dnorm(sfactorTdn(obsx[i], e1,0.0912, gin, gout,6,5,0),sd)
}
for (j in 1:150){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1,0.0912, gin, gout,6,5,0)
}
sd ~  dgamma(0.1,0.1)
e1 ~  dgamma(0.1,0.1)
gin ~  dgamma(0.1,0.1)
gout ~ dgamma(0.1,0.1)
})
model
mcmc.output <- nimbleMCMC(model, data = model.data, inits = inits,
monitors = c("e1", "gin", "gout","sd"), thin = 10,
niter = 20000, nburnin = 1000, nchains = 3,
summary = TRUE, WAIC = TRUE)
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
mcmc.output <- nimbleMCMC(model, data = model.data, inits = inits,
monitors = c("e1", "gin", "gout","sd"), thin = 10,
niter = 20000, nburnin = 1000, nchains = 3,
summary = TRUE, WAIC = TRUE)
help(nimbleRcall)
samplesList <- runMCMC(Rmodel, niter = 10000, nchains = 3, inits = inits)
######################################################################
# preparation: remove all variables from the work space
#rm(list=ls())
set.seed(123)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(gsl);library(latex2exp)
require(runjags);require(gsl)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
## ARTIFICIAL DATA GENERATION
N <- 150
#obsx1 <- runif(N,0,0.7)
obsx1 <- exp(runif(N,log(1e-3),log(1)))
sd <- 0.1
obsy1 <- rnorm(N, Sfactor3(obsx1,0.0912,0.0912,2.93,0.0794,6,5,0),sd=sd)
M <- 150
xx <- seq(min(obsx1),max(obsx1),length.out = M)
model.data <- list(obsy = obsy1,    # Response variable
obsx =  obsx1,   # Predictors
#                   erry = errobsy1,
N = N, # Sample size
M = M,
xx = xx
)
#
sfactorTdn <- nimbleRcall(function(obsx1 = double(1),
e1 = double(1),ex = double(1),gin = double(1),
gout = double(1),ri = double(1),rf = double(1),ue = double(1)){}, Rfun = 'Sfactor3',
returnType = double(1), envir = .GlobalEnv)
model <- nimbleCode({
for (i in 1:150) {
obsy[i] ~ dnorm(sfactorTdn(obsx[i], e1,0.0912, gin, gout,6,5,0),sd)
}
for (j in 1:150){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1,0.0912, gin, gout,6,5,0)
}
sd ~  dgamma(0.1,0.1)
e1 ~  dgamma(0.1,0.1)
gin ~  dgamma(0.1,0.1)
gout ~ dgamma(0.1,0.1)
})
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
Rmodel <- nimbleModel(code)
Rmodel <- nimbleModel(model)
samplesList <- runMCMC(Rmodel, niter = 10000, nchains = 3, inits = inits)
compileNimble(Rmodel)
Rmodel <- nimbleModel(model)
samplesList <- runMCMC(Rmodel, niter = 10000, nchains = 3, inits = inits)
Rmodel <- nimbleModel(model)
require(gsl)
model <- nimbleCode({
for (i in 1:150) {
obsy[i] ~ dnorm(sfactorTdn(obsx[i], e1,0.0912, gin, gout,6,5,0),sd)
}
for (j in 1:150){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1,0.0912, gin, gout,6,5,0)
}
sd ~  dgamma(0.1,0.1)
e1 ~  dgamma(0.1,0.1)
gin ~  dgamma(0.1,0.1)
gout ~ dgamma(0.1,0.1)
})
inits <- function () { list(e1 = runif(1,0.01,1),gout=runif(1,0.01,1),gin=runif(1,0.01,1)) }
Rmodel <- nimbleModel(model)
model <- nimbleCode({
for (i in 1:150) {
obsy[i] ~ dnorm(sfactorTdn(obsx[i], e1,0.0912, gin, gout,6,5,0),sd)
}
for (j in 1:150){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1,0.0912, gin, gout,6,5,0)
}
sd ~  dunif(0.01,2)
e1 ~  dgamma(0.1,0.1)
gin ~  dgamma(0.1,0.1)
gout ~ dgamma(0.1,0.1)
})
inits <- function () { list(e1 = runif(1,0.01,1),gout=runif(1,0.01,1),gin=runif(1,0.01,1)) }
Rmodel <- nimbleModel(model)
model <- nimbleCode({
for (i in 1:150) {
obsy[i] ~ dnorm(sfactorTdn(obsx[i], e1,0.0912, gin, gout,6,5,0),sd)
}
for (j in 1:150){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1,0.0912, gin, gout,6,5,0)
}
sd ~  dunif(0.01,2)
e1 ~  dunif(0.01,1)
gin ~  dgamma(0.1,0.1)
gout ~ dgamma(0.1,0.1)
})
inits <- function () { list(e1 = runif(1,0.01,1),gout=runif(1,0.01,1),gin=runif(1,0.01,1)) }
Rmodel <- nimbleModel(model)
model <- nimbleCode({
for (i in 1:150) {
obsy[i] ~ dnorm(sfactorTdn(obsx[i], e1,0.0912, gin, gout,6,5,0),sd)
}
for (j in 1:150){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1,0.0912, gin, gout,6,5,0)
}
sd ~  dunif(0.01,2)
e1 ~  dunif(0.01,1)
gin ~  dunif(0.01,4)
gout ~ dunif(0.01,4)
})
inits <- function () { list(e1 = runif(1,0.01,1),gout=runif(1,0.01,1),gin=runif(1,0.01,1)) }
Rmodel <- nimbleModel(model)
nimbleModel(model)
model
sfactorTdn <- nimbleRcall(function(obsx1 = double(1),
e1 = double(1),ex = double(1),gin = double(1),
gout = double(1),ri = double(1),rf = double(1),ue = double(1)){}, Rfun = 'Sfactor3',
returnType = double(1), envir = .GlobalEnv)
sfactorTdn(0.1,1,1,1,1,1,1,0)
model <- nimbleCode({
for (i in 1:150) {
obsy[i] ~ dnorm(sfactorTdn(obsx[i], e1,0.0912, gin, gout,6,5,0),sd)
}
for (j in 1:150){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1,0.0912, gin, gout,6,5,0)
}
sd ~  dunif(0.01,1)
e1 ~  dunif(0.01,1)
gin ~  dunif(0.01,4)
gout ~ dunif(0.01,4)
})
inits <- function () { list(e1 = runif(1,0.01,1),gout=runif(1,0.01,1),gin=runif(1,0.01,1)) }
Rmodel <- nimbleModel(model)
model$initializeInfo()
model$initializeInfo
model <- nimbleCode({
for (i in 1:150) {
obsy[i] ~ dnorm(sfactorTdn(obsx[i], e1,0.0912, gin, gout,6,5,0),sd)
}
sd ~  dunif(0.01,1)
e1 ~  dunif(0.01,1)
gin ~  dunif(0.01,4)
gout ~ dunif(0.01,4)
})
inits <- function () { list(e1 = runif(1,0.01,1),gout=runif(1,0.01,1),gin=runif(1,0.01,1)) }
Rmodel <- nimbleModel(model)
model <- nimbleCode({
for (i in 1:150) {
obsy[i] ~ dnorm(sfactorTdn(obsx[i], e1,0.0912, gin, gout,6,5,0),sd)
}
sd ~  dunif(0.01,1)
e1 ~  dunif(0.01,1)
gin ~  dunif(0.01,1)
gout ~ dunif(1,4)
})
inits <- function () { list(e1 = runif(1,0.01,1),gout=runif(1,0.01,1),gin=runif(1,0.01,1)) }
Rmodel <- nimbleModel(model)
runMCMC(model, niter = 1000, nchains = 3, inits = inits)
buildMCMC(model)
nimbleModel(model,data = model.data, inits = inits)
inits
nimbleModel(model,data = model.data, inits = inits)
inits <- list(e1 = runif(1,0.01,1),gout=runif(1,0.01,1),gin=runif(1,0.01,1))
Rmodel <- nimbleModel(model,data = model.data, inits = inits)
mcmcConf <- configureMCMC(Rmodel, monitors = c("e1", "gin", "gout","sd"))
samplesList <- runMCMC(mcmcConf, niter = 1000, nchains = 3, inits = inits)
mcmcConf
Rmodel <- nimbleModel(model,data = model.data, inits = inits)
mcmcConf <- configureMCMC(Rmodel, monitors = c("e1", "gin", "gout","sd"))
samplesList <- runMCMC(Rmodel, niter = 1000, nchains = 3, inits = inits)
mcmc_CL <- buildMCMC(mcmcConf)
samplesList <- runMCMC(mcmc_CL, niter = 1000, nchains = 3, inits = inits)
samplesList
compileNimble(mcmc_CL)
compileNimble(Rmodel,showCompilerOutput = TRUE)
samplesList <- runMCMC(mcmc_CL, niter = 5000, nchains = 3, inits = inits)
3.26*3300
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/Tdn/Synthetic")
library(LaplacesDemon)
require(gsl)
source("Sfactor3.R")
N <- 150
#obsx1 <- runif(N,0,0.7)
obsx1 <- exp(runif(N,log(1e-3),log(1)))
sd <- 1
# Artificial values, here we will just fit 3 parameters Er, gi, gf
y <- rnorm(N, Sfactor3(obsx1,0.0912,0.0912,2.93,0.0794,6,5,0),sd = sd)
mon.names <- c("LP","Er","gi","gf")
parm.names <- c("Er","gi","gf","sigma")
pos.Er <- 1
pos.gi <- 2
pos.gf <- 3
pos.sigma <- 4
PGF <- function(Data) {
Er <- runif(1)
gi <- runif(1)
gi <- runif(1)
sigma <- runif(1)
return(c(Er,gi,gi, sigma))
}
MyData <- list(J=4, PGF=PGF, X=obsx1, mon.names=mon.names,
parm.names=parm.names, pos.Er=pos.Er,pos.gi = pos.gi,pos.gf=pos.gf, pos.sigma=pos.sigma, y=y)
Model <- function(parm, Data)
{
### Parameters
Er <- parm[Data$pos.Er]
gi <- parm[Data$pos.gi]
gf <- parm[Data$pos.gf]
sigma <- interval(parm[Data$pos.sigma], 1e-100, Inf)
parm[Data$pos.sigma] <- sigma
### Log(Prior Densities)
Er.prior <- dunif(Er,0, 10, log=TRUE)
gi.prior <- dunif(gi,0, 10, log=TRUE)
gf.prior <- dunif(gf,0, 5, log=TRUE)
sigma.prior <- dhalfcauchy(sigma, 5, log=TRUE)
### Log-Likelihood
mu <- Sfactor3(obsx1,Er,0.0912,gi,gf,6,5,0)
LL <- sum(dnorm(y, mu, sigma, log=TRUE))
LP <- LL + Er.prior + gi.prior + gf.prior + sigma.prior
Modelout <- list(LP=LP, Dev=-2*LL, Monitor = c(LP, Er,gi,gf),
yhat=0,#rnorm(length(mu), mu, sigma),
parm=parm)
return(Modelout)
}
Initial.Values <- rep(0.5,4)
########################  Laplace Approximation  ##########################
Fit <- LaplaceApproximation(Model, Initial.Values, Data=MyData,
Iterations=10000, Method="NM", CPUs=1)
print(Fit)
rep(0.5,4)
Initial.Values <- rep(runif(4,0,1))
########################  Laplace Approximation  ##########################
Fit <- LaplaceApproximation(Model, Initial.Values, Data=MyData,
Iterations=10000, Method="NM", CPUs=1)
print(Fit)
LaplacesDemon(Model, Data=MyData, Initial.Values,
Iterations=5000, Status=100, Thinning=1,
Algorithm="HMC", Specs=list(epsilon=0.001, L=2, m=NULL))
Model <- function(parm, Data)
{
### Parameters
Er <- parm[Data$pos.Er]
gi <- parm[Data$pos.gi]
gf <- parm[Data$pos.gf]
sigma <- interval(parm[Data$pos.sigma], 1e-100, Inf)
parm[Data$pos.sigma] <- sigma
### Log(Prior Densities)
Er.prior <- dunif(Er,0, 10, log=TRUE)
gi.prior <- dunif(gi,0, 10, log=TRUE)
gf.prior <- dunif(gf,0, 10, log=TRUE)
sigma.prior <- dhalfcauchy(sigma, 5, log=TRUE)
### Log-Likelihood
mu <- Sfactor3(obsx1,Er,0.0912,gi,gf,6,5,0)
LL <- sum(dnorm(y, mu, sigma, log=TRUE))
LP <- LL + Er.prior + gi.prior + gf.prior + sigma.prior
Modelout <- list(LP=LP, Dev=-2*LL, Monitor = c(LP, Er,gi,gf),
yhat=0,#rnorm(length(mu), mu, sigma),
parm=parm)
return(Modelout)
}
Initial.Values <- rep(runif(4,0,1))
########################  Laplace Approximation  ##########################
Fit <- LaplaceApproximation(Model, Initial.Values, Data=MyData,
Iterations=10000, Method="NM", CPUs=1)
print(Fit)
