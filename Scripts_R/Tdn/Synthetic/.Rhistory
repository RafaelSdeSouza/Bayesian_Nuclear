N <- 150
#obsx1 <- runif(N,0,0.7)
obsx1 <- exp(runif(N,log(1e-3),log(1)))
sd <- 0.1
obsy1 <- rnorm(N, Sfactor3(obsx1,0.0912,0.0912,2.93,0.0794,6,5,0),sd=sd)
M <- 150
xx <- seq(min(obsx1),max(obsx1),length.out = M)
model.data <- list(obsy = obsy1,    # Response variable
obsx =  obsx1,   # Predictors
#                   erry = errobsy1,
N = N, # Sample size
M = M,
xx = xx
)
#
require(gsl)
Sfactor3 <- function(ECM, E1, EX, gi, gf, ri, rf, ue){
# input masses, charges, angular momenta
m1_i = 3.01550
m2_i = 2.01355        # masses (amu) of t and d
m1_f = 4.00151
m2_f = 1.008664       # masses (amu) of n and 4He
z1_i = 1
z2_i = 1              # charges of t and d
z1_f = 2
z2_f = 0				# charges of n and 4He
jt=0.5                # spins of target, projectile, resonance
jp=1.0
jr=1.5
Q = 17.589293			# reaction Q-value (MeV)
la = 0
lb = 2				# orbital angular momenta of d and n
# reduced masses
mue_i <- (m1_i*m2_i)/(m1_i+m2_i)
mue_f <- (m1_f*m2_f)/(m1_f+m2_f)
# constants
pek <- 6.56618216e-1/mue_i
omega <- (2*jr+1)/((2*jt+1)*(2*jp+1))
### CALCULATE S-FACTOR
## incoming channel
etpe_i=exp(0.98951013*z1_i*z2_i*sqrt(mue_i/ECM))
eta_a=0.1574854*z2_i*z1_i*sqrt(mue_i)
rho_a=0.218735*ri*sqrt(mue_i)
eta_i=eta_a/(sqrt(ECM))
rho_i=rho_a*(sqrt(ECM))
P3 <- coulomb_wave_FG(eta_i, rho_i, la, k=0)
# penetration and shift factor
p_i <- rho_i/(P3$val_F^2 + P3$val_G^2)
s_i <- rho_i*(P3$val_F*P3$val_Fp + P3$val_G*P3$val_Gp)/(P3$val_F^2 + P3$val_G^2)
# shift factor at observed energy Ex
xeta_i=eta_a/(sqrt(EX))
xrho_i=rho_a*(sqrt(EX))
PX1 <- coulomb_wave_FG(xeta_i, xrho_i, la, k=0)
b_i <- xrho_i*(PX1$val_F*PX1$val_Fp + PX1$val_G*PX1$val_Gp)/(PX1$val_F^2 + PX1$val_G^2)
# partial width
Ga <- 2*gi*p_i
## outgoing channel
eta_b=0.1574854*z2_f*z1_f*sqrt(mue_f)
rho_b=0.218735*rf*sqrt(mue_f)
eta_f=eta_b/(sqrt(ECM+Q))
rho_f=rho_b*(sqrt(ECM+Q))
P4 <- coulomb_wave_FG(eta_f, rho_f, lb, k=0)
# penetration and shift factor
p_f <- rho_f/(P4$val_F^2 + P4$val_G^2)
s_f <- rho_f*(P4$val_F*P4$val_Fp + P4$val_G*P4$val_Gp)/(P4$val_F^2 + P4$val_G^2)
# shift factor at observed energy Ex+Q
xeta_f=eta_b/(sqrt(EX+Q))
xrho_f=rho_b*(sqrt(EX+Q))
PX2 <- coulomb_wave_FG(xeta_f, xrho_f, lb, k=0)
b_f <- xrho_f*(PX2$val_F*PX2$val_Fp + PX2$val_G*PX2$val_Gp)/(PX2$val_F^2 + PX2$val_G^2)
# partial width
Gb <- 2*gf*p_f
tapp <- (s_i-b_i)*gi+(s_f-b_f)*gf
s1=pek*etpe_i*omega*Ga*Gb
s2=((E1-ECM-tapp)^2)+0.25*((Ga+Gb)^2)
SF <- exp( 0.5*0.98951013e0*z1_i*z2_i*sqrt(mue_i)*ue*ECM^(-1.5) )*s1/s2
return(SF = SF)
}
# 3Hedp analysis
#
# purpose: Real  DATA
#
# - 5 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorHe3dp(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
######################################################################
# preparation: remove all variables from the work space
#rm(list=ls())
set.seed(123)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(gsl);library(latex2exp)
require(runjags)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
## ARTIFICIAL DATA GENERATION
N <- 150
#obsx1 <- runif(N,0,0.7)
obsx1 <- exp(runif(N,log(1e-3),log(1)))
sd <- 0.1
obsy1 <- rnorm(N, Sfactor3(obsx1,0.0912,0.0912,2.93,0.0794,6,5,0),sd=sd)
M <- 150
xx <- seq(min(obsx1),max(obsx1),length.out = M)
model.data <- list(obsy = obsy1,    # Response variable
obsx =  obsx1,   # Predictors
#                   erry = errobsy1,
N = N, # Sample size
M = M,
xx = xx
)
#
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
#obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
obsy[i] ~ dnorm(sfactorTdn3(obsx[i], e1,0.0912, gin, gout,6,5,0),pow(tau, -2))
res[i] <- obsy[i]-sfactorTdn3(obsx[i], e1,0.0912, gin, gout,6,5,0)
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactorTdn3(xx[j], e1,0.0912, gin, gout,6,5,0)
}
# PRIORS
tau ~  dgamma(0.1,0.1)
e1 ~  dnorm(0,0.1)T(0,)
gin ~  dnorm(0,pow(0.5,-2))T(0,)
gout ~ dnorm(0,pow(0.5,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
Normfit <- run.jags(data = model.data,
adapt = 50000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 50,
burnin = 5000,
sample = 10000,
n.chains = 3)
Normfit
plot(Normfit, layout=c(3,4))
Normfit <- run.jags(data = model.data,
adapt = 10000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 10,
burnin = 5000,
sample = 5000,
n.chains = 3)
Normfit
plot(Normfit, layout=c(3,4))
Normfit
plot(obsx1,obsy1)
plot(obsx1,obsy1,log="y")
plot(obsx1,obsy1,log="x")
Sfactor3 <- function(ECM, E1, EX, gi, gf, ri, rf, ue){
# constants
m1_i = 3.01550
m2_i = 2.01355        # masses (amu) of t and d
m1_f = 4.00151
m2_f = 1.008664       # masses (amu) of n and 4He
z1_i = 1
z2_i = 1              # charges of t and d
z1_f = 2
z2_f = 0				#charges of n and 4He
jt=0.5
jp=1.0
jr=1.5                # spins of target, projectile, resonance
Q = 17.589293			# reaction Q-value (MeV)
la = 0
lb = 2				# orbital angular momenta of d and n
# reduced masses
mue_i <- (m1_i*m2_i)/(m1_i+m2_i)
mue_f <- (m1_f*m2_f)/(m1_f+m2_f)
# constants
pek <- 6.56618216e-1/mue_i
omega <- (2*jr+1)/((2*jt+1)*(2*jp+1))
### CALCULATE S-FACTOR
## incoming channel
etpe_i=exp(0.98951013*z1_i*z2_i*sqrt(mue_i/ECM))
eta_a=0.1574854*z2_i*z1_i*sqrt(mue_i)
rho_a=0.218735*ri*sqrt(mue_i)
eta_i=eta_a/(sqrt(ECM))
rho_i=rho_a*(sqrt(ECM))
P3 <- coulomb_wave_FG(eta_i, rho_i, la, k=0)
# penetration and shift factor
p_i <- rho_i/(P3$val_F^2 + P3$val_G^2)
s_i <- rho_i*(P3$val_F*P3$val_Fp + P3$val_G*P3$val_Gp)/(P3$val_F^2 + P3$val_G^2)
# shift factor at observed energy Ex
xeta_i=eta_a/(sqrt(EX))
xrho_i=rho_a*(sqrt(EX))
PX1 <- coulomb_wave_FG(xeta_i, xrho_i, la, k=0)
b_i <- xrho_i*(PX1$val_F*PX1$val_Fp + PX1$val_G*PX1$val_Gp)/(PX1$val_F^2 + PX1$val_G^2)
# partial width
Ga <- 2*gi*p_i
## outgoing channel
eta_b=0.1574854*z2_f*z1_f*sqrt(mue_f)
rho_b=0.218735*rf*sqrt(mue_f)
eta_f=eta_b/(sqrt(ECM+Q))
rho_f=rho_b*(sqrt(ECM+Q))
P4 <- coulomb_wave_FG(eta_f, rho_f, lb, k=0)
# penetration and shift factor
p_f <- rho_f/(P4$val_F^2 + P4$val_G^2)
s_f <- rho_f*(P4$val_F*P4$val_Fp + P4$val_G*P4$val_Gp)/(P4$val_F^2 + P4$val_G^2)
# shift factor at observed energy Ex+Q
xeta_f=eta_b/(sqrt(EX+Q))
xrho_f=rho_b*(sqrt(EX+Q))
PX2 <- coulomb_wave_FG(xeta_f, xrho_f, lb, k=0)
b_f <- xrho_f*(PX2$val_F*PX2$val_Fp + PX2$val_G*PX2$val_Gp)/(PX2$val_F^2 + PX2$val_G^2)
# partial width
Gb <- 2*gf*p_f
tapp <- (s_i-b_i)*gi+(s_f-b_f)*gf
s1=pek*etpe_i*omega*Ga*Gb
s2=((E1-ECM-tapp)^2)+0.25*((Ga+Gb)^2)
SF <- exp( 0.5*0.98951013e0*z1_i*z2_i*sqrt(mue_i)*ue*ECM^(-1.5) )*s1/s2
return(SF = SF)
}
######################################################################
## ARTIFICIAL DATA GENERATION
N <- 150
#obsx1 <- runif(N,0,0.7)
obsx1 <- exp(runif(N,log(1e-3),log(1)))
sd <- 0.1
obsy1 <- rnorm(N, Sfactor3(obsx1,0.0912,0.0912,2.93,0.0794,6,5,0),sd=sd)
M <- 150
xx <- seq(min(obsx1),max(obsx1),length.out = M)
model.data <- list(obsy = obsy1,    # Response variable
obsx =  obsx1,   # Predictors
#                   erry = errobsy1,
N = N, # Sample size
M = M,
xx = xx
)
#
plot(obsx1,obsy1,log="x")
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
#obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
obsy[i] ~ dnorm(sfactorTdn3(obsx[i], e1,0.0912, gin, gout,6,5,0),pow(tau, -2))
res[i] <- obsy[i]-sfactorTdn3(obsx[i], e1,0.0912, gin, gout,6,5,0)
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactorTdn3(xx[j], e1,0.0912, gin, gout,6,5,0)
}
# PRIORS
tau ~  dgamma(0.1,0.1)
e1 ~  dnorm(0,0.1)T(0,)
gin ~  dnorm(0,pow(0.5,-2))T(0,)
gout ~ dnorm(0,pow(0.5,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- run.jags(data = model.data,
adapt = 1000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 1,
burnin = 2000,
sample = 5000,
n.chains = 3)
Normfit
require(gsl)
Sfactor3 <- function(ECM, E1, EX, gi, gf, ri, rf, ue){
# constants
m1_i = 3.01550
m2_i = 2.01355        # masses (amu) of t and d
m1_f = 4.00151
m2_f = 1.008664       # masses (amu) of n and 4He
z1_i = 1
z2_i = 1              # charges of t and d
z1_f = 2
z2_f = 0				#charges of n and 4He
jt=0.5
jp=1.0
jr=1.5                # spins of target, projectile, resonance
Q = 17.589293			# reaction Q-value (MeV)
la = 0
lb = 2				# orbital angular momenta of d and n
# reduced masses
mue_i <- (m1_i*m2_i)/(m1_i+m2_i)
mue_f <- (m1_f*m2_f)/(m1_f+m2_f)
# constants
pek <- 6.56618216e-1/mue_i
omega <- (2*jr+1)/((2*jt+1)*(2*jp+1))
### CALCULATE S-FACTOR
## incoming channel
etpe_i=exp(0.98951013*z1_i*z2_i*sqrt(mue_i/ECM))
eta_a=0.1574854*z2_i*z1_i*sqrt(mue_i)
rho_a=0.218735*ri*sqrt(mue_i)
eta_i=eta_a/(sqrt(ECM))
rho_i=rho_a*(sqrt(ECM))
P3 <- coulomb_wave_FG(eta_i, rho_i, la, k=0)
# penetration and shift factor
p_i <- rho_i/(P3$val_F^2 + P3$val_G^2)
s_i <- rho_i*(P3$val_F*P3$val_Fp + P3$val_G*P3$val_Gp)/(P3$val_F^2 + P3$val_G^2)
# shift factor at observed energy Ex
xeta_i=eta_a/(sqrt(EX))
xrho_i=rho_a*(sqrt(EX))
PX1 <- coulomb_wave_FG(xeta_i, xrho_i, la, k=0)
b_i <- xrho_i*(PX1$val_F*PX1$val_Fp + PX1$val_G*PX1$val_Gp)/(PX1$val_F^2 + PX1$val_G^2)
# partial width
Ga <- 2*gi*p_i
## outgoing channel
eta_b=0.1574854*z2_f*z1_f*sqrt(mue_f)
rho_b=0.218735*rf*sqrt(mue_f)
eta_f=eta_b/(sqrt(ECM+Q))
rho_f=rho_b*(sqrt(ECM+Q))
P4 <- coulomb_wave_FG(eta_f, rho_f, lb, k=0)
# penetration and shift factor
p_f <- rho_f/(P4$val_F^2 + P4$val_G^2)
s_f <- rho_f*(P4$val_F*P4$val_Fp + P4$val_G*P4$val_Gp)/(P4$val_F^2 + P4$val_G^2)
# shift factor at observed energy Ex+Q
xeta_f=eta_b/(sqrt(EX+Q))
xrho_f=rho_b*(sqrt(EX+Q))
PX2 <- coulomb_wave_FG(xeta_f, xrho_f, lb, k=0)
b_f <- xrho_f*(PX2$val_F*PX2$val_Fp + PX2$val_G*PX2$val_Gp)/(PX2$val_F^2 + PX2$val_G^2)
# partial width
Gb <- 2*gf*p_f
tapp <- (s_i-b_i)*gi+(s_f-b_f)*gf
s1=pek*etpe_i*omega*Ga*Gb
s2=((E1-ECM-tapp)^2)+0.25*((Ga+Gb)^2)
SF <- exp( 0.5*0.98951013e0*z1_i*z2_i*sqrt(mue_i)*ue*ECM^(-1.5) )*s1/s2
return(SF = SF)
}
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/Tdn/Synthetic")
# 3Hedp analysis
#
# purpose: Real  DATA
#
# - 5 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorHe3dp(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
######################################################################
# preparation: remove all variables from the work space
#rm(list=ls())
set.seed(123)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(gsl);library(latex2exp)
require(runjags)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
## ARTIFICIAL DATA GENERATION
N <- 150
#obsx1 <- runif(N,0,0.7)
obsx1 <- exp(runif(N,log(1e-3),log(1)))
sd <- 0.1
obsy1 <- rnorm(N, Sfactor3(obsx1,0.0912,0.0912,2.93,0.0794,6,5,0),sd=sd)
M <- 150
xx <- seq(min(obsx1),max(obsx1),length.out = M)
model.data <- list(obsy = obsy1,    # Response variable
obsx =  obsx1,   # Predictors
#                   erry = errobsy1,
N = N, # Sample size
M = M,
xx = xx
)
#
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
#obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
obsy[i] ~ dnorm(sfactorTdn(obsx[i], e1,0.0912, gin, gout,6,5,0),pow(tau, -2))
res[i] <- obsy[i]-sfactorTdn(obsx[i], e1,0.0912, gin, gout,6,5,0)
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactorTdn(xx[j], e1,0.0912, gin, gout,6,5,0)
}
# PRIORS
tau ~  dgamma(0.1,0.1)
e1 ~  dnorm(0,0.1)T(0,)
gin ~  dnorm(0,pow(0.5,-2))T(0,)
gout ~ dnorm(0,pow(0.5,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- run.jags(data = model.data,
adapt = 1000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 1,
burnin = 2000,
sample = 5000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
Normfit
# JAGS model with R2Jags;
Normfit <- run.jags(data = model.data,
adapt = 10000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 1,
burnin = 2000,
sample = 5000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
Normfit <- run.jags(data = model.data,
adapt = 15000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 1,
burnin = 5000,
sample = 10000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
Normfit <- run.jags(data = model.data,
adapt = 15000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 5,
burnin = 5000,
sample = 10000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
# JAGS model with R2Jags;
Normfit
