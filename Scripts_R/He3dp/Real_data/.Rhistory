coulomb_wave_FG(1, 1, 1, k = 0)
coulomb_wave_FG(Er, 1, 1, k = 0)
Er
uniform(min = 0.001, max = 50)
muF <- function(obsx1,Er,gi,gf){sfactorTdn_5p(obsx1,Er,gi,gf,6,5)}
muF(obsx1,Er,gi,gf,6,5)
muF(obsx1,Er,gi,gf)
as.matrix(Er)[[1]]
if (is.na(as.matrix(Er)[[1]])){
xx <- runif(1,0,1)
mean = sfactorTdn_5p(obsx1,xx,gi,gf,6,5)
}else{
mean = muF(obsx1,Er,gi,gf)
}
# likelihood
distribution(y) = normal(mean, sd)
# defining the model
m <- model(Er, gi, gf,sd)
# plotting
plot(m)
# sampling
draws <- mcmc(m, warmup = 500,n_samples = 1000,chains = 1)
muF <- function(obsx1,Er,gi,gf){
if (is.na(as.matrix(Er)[[1]])){
xx <- runif(1,0,1)
mean = sfactorTdn_5p(obsx1,xx,gi,gf,6,5)
}else{
mean = sfactorTdn_5p(obsx1,Er,gi,gf,6,5)
}
}
muF <- function(obsx1,Er,gi,gf){
if (is.na(as.matrix(Er)[[1]])){
xx <- runif(1,0,1)
mean = sfactorTdn_5p(obsx1,xx,gi,gf,6,5)
}else{
mean = sfactorTdn_5p(obsx1,Er,gi,gf,6,5)
}
return(mean)
}
muF(1,Er,1,1)
muF(1,Er,1,1)
Er
muF(1,3,1,1)
mean = muF(obsx1,Er,gi,gf)
# likelihood
distribution(y) = normal(mean, sd)
# defining the model
m <- model(Er, gi, gf,sd)
# plotting
plot(m)
# sampling
draws <- mcmc(m, warmup = 500,n_samples = 1000,chains = 1)
draws
y
is.na(as.matrix(Er)[[1]])
Er
sfactorTdn_5p(obsx1,Er,gi,gf,6,5)
sfactorTdn_5p(obsx1,NA,gi,gf,6,5)
sfactorTdn_5p(obsx1,NULL,gi,gf,6,5)
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/He3dp/Real_data")
# 3Hedp analysis
#
# purpose: Real  DATA
#
# - 5 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorHe3dp(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
######################################################################
# preparation: remove all variables from the work space
#rm(list=ls())
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(MCMCvis)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
source("..//..//auxiliar_functions/table_reaction.R")
## for block updating [we do not need to center predictor variables]
#load.module("glm")
load.module("nuclear")
######################################################################
## Read DATA
ensamble <- read.csv("ensamble.csv",header = T) %>%
mutate(Syst=replace(Syst,Syst==0.06,0.078))  %>% filter(E <= 0.5)
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
ik <- as.numeric(ensamble$invK)
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
# Literature
#  0.35779   # resonance energy
#  1.0085    # reduced width incoming
#  0.025425   # reduced width outgoing
N <- nrow(ensamble)
obsy <- ensamble$S    # Response variable
obsx <-  ensamble$E   # Predictors
erry <- ensamble$Stat
set <- ensamble$dat
lab <- ensamble$invK
syst = c(0.03,unique(ensamble$Syst))
#syst <- syst[-3]
M <- 500
xx <- seq(min(obsx),max(obsx),length.out = M)
model.data <- list(obsy = obsy,    # Response variable
obsy2 = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble), # Sample size
syst = syst,
Nre = Nre,
re = re,
Nik = Nik,
ik  = ik,
M = M,
xx = xx,
ap  = 5,
ad = 6
)
# Conservative case
######################################################################
Model <- "model{
# LIKELIHOOD informative
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], E0, Er, gd2, gp2, ad, ap, ue[ik[i]]), pow(tau, -2))
res[i] <- obsy[i]-sfactor3Hedp(obsx[i], E0, Er, gd2, gp2, ad, ap,0)
}
# LIKELIHOOD broad
for (i in 1:N) {
obsy2[i] ~ dnorm(y_2[i], pow(erry[i], -2))
y_2[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i],  E0_b, Er_b, gd2_b, gp2_b, ad_b, ap_b, ue[ik[i]]),pow(tau_2, -2))
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,0)
mux0_2[j] <- sfactor3Hedp(xx[j], E0_b, Er_b, gd2_b, gp2_b, ad_b, ap_b,0)
DeltaM[j] <- (mux0[j] - mux0_2[j])/mux0[j]
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,pow(0.1,-2))T(0,)
}
# PRIORS 1
tau ~  dnorm(0, pow(1,-2))T(0,)
E0 ~  dnorm(0, pow(1,-2))T(0,)
Er <-  E0
gd2 ~  dnorm(0, pow(1,-2))T(0,)
gp2 ~ dnorm(0, pow(1,-2))T(0,)
#  Transform
gd <- sqrt(gd2)
gp <- sqrt(gp2)
ue_ev[1] <-1e6*ue[1]
ue_ev[2] <-1e6*ue[2]
gd_b <- sqrt(gd2_b)
gp_b <- sqrt(gp2_b)
tau_2  ~    dnorm(0, pow(5,-2))T(0,)
E0_b  ~  dnorm(0, pow(1,-2))T(0,)
Er_b  ~  dnorm(0, pow(1,-2))T(0,)
#Er_b  <- E0_b
gd2_b ~  dnorm(0, pow(1,-2))T(0,)
gp2_b ~ dnorm(0, pow(1,-2))T(0,)
ad_b ~  dnorm(5, pow(2.5,-2))T(0,)
ap_b ~  dnorm(5, pow(2.5,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(Er = runif(1,0.3,0.4),  gd2 = runif(1,2,5), gp2 = runif(1,0.01,0.08)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
##require(runjags)
#m <- run.jags(model = Model,
#              monitor = c("e1","gin", "gout","ue","tau", "ri","rf",
#                          "e1_2","ex_2","gin_2", "gout_2","tau_2","ri_2","rf_2" ),
#              data = model.data,
#              n.chains = 10,
#              inits = inits,
#              burnin = 1000,
#              sample = 5000,
#              adapt = 2000
#)
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("Er","gd", "gp","ue_ev","tau", "ad","ap","RSS","mux0","mux1","mux2","scale","DeltaM",
"E0_b","Er_b","gd_b", "gp_b","tau_2","ad_b","ap_b" ),
model.file  = textConnection(Model),
n.thin = 200,
n.chains = 3,
n.burnin = 2500,
n.iter = 10000)
jagsresults(x = Normfit, params = c("Er","gd", "gp","ue","tau", "ad","ap","ue_ev"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
Normfit <- update(Normfit, n.thin = 200, n.iter=5000)
jagsresults(x = Normfit, params = c("Er","gd", "gp","ue","tau", "ad","ap","ue_ev"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
Sp <- ggs(as.mcmc(Normfit)[,c("Er", "gd", "gp","ue_ev[1]","ue_ev[2]")])
#DD <- as.matrix(as.mcmc(Normfit)[,c("e1", "gin", "gout")])
Sp0 <- Sp %>% as_tibble()
#%>% mutate(value = ifelse(Parameter == 'e1', 10*value, value))
levels(Sp0$Parameter) <- as.factor(c("E[0]","gamma[d]", "gamma[p]","Ue[1]", "Ue[2]"))
pair_wise_plot(Sp0)
library("ggridges", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
pair_wise_plot(Sp0)
pair_wise_plot(Sp0)
pair_wise_plot(Sp0)
pdf("plot/He3dp_corr.pdf",height = 6,width =6)
pair_wise_plot(Sp0)
dev.off()
jagsresults(x = Normfit, params = c("Er","gd", "gp","ue","tau", "ad","ap","ue_ev"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
Normfit <- update(Normfit, n.thin = 200, n.iter=10000)
pair_wise_plot <- function(s){
my_hist <- function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
stat_density_ridges(aes(y=0,fill=factor(..quantile..),alpha=factor(..quantile..)),geom = "density_ridges_gradient", calc_ecdf = TRUE, alpha=0.3,
quantile_lines = TRUE,quantiles = c(0.025, 0.25,  0.75, 0.975)) +
scale_fill_manual(name = "Probability", values = c("gray90", "gray70", "gray30",
"gray70","gray90" ))+
#     geom_histogram(bins = 10,fill="#bf812d",colour="#1F3552",...) +
#    geom_density(adjust = 1.5,fill="#bf812d",colour="#1F3552",...) +
theme_void() + theme( panel.grid.minor=element_blank(),
panel.grid.major = element_blank())
}
my_bin <- function(data, mapping, ..., low = "gray80", high = "gray15") {
# get the x and y data to use the other code
ggplot(data = data, mapping = mapping,linetype-"dashed",color="red") +
stat_density_2d(aes(fill =..level..,alpha =..level..),geom="polygon",...) +
#    stat_ellipse(type = "norm",level = 0.95,geom = "polygon",fill="#feb24c",...) +
#    stat_ellipse(type = "norm",level = 0.68,geom = "polygon",fill="#f03b20",...) +
#    geom_point() +
#   stat_ellipse(type = "t",level = 0.997,alpha=0.95,color="#dfc27d",...) +
#    stat_ellipse(type = "t",level = 0.95,alpha=0.95,color="red",...) +
#   stat_ellipse(type = "t",level = 0.68,alpha=0.95,color="red2",...) +
scale_x_continuous(breaks = scales::pretty_breaks(n = 4)) +
scale_y_continuous(breaks = scales::pretty_breaks(n = 4)) +
scale_fill_gradient(low = low, high = high) +
theme_bw() +
theme( text = element_text(size=60),axis.text = element_text(size=9.5),
axis.text.x = element_text(size=8, angle=25),
axis.text.y = element_text(size=8),
strip.text.x = element_text(colour = 'red',size = 20),
strip.text.y = element_text(colour = 'red',size = 20),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
}
ggs_pairs(s,
labeller = "label_parsed",
diag=list(continuous = my_hist),
upper = "blank",
lower = list(continuous = my_bin),
switch="both",
showStrips=FALSE
) }
jagsresults(x = Normfit, params = c("Er","gd", "gp","ue","tau", "ad","ap","ue_ev"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
traplot(Normfit  ,c("Er","gd", "gp","ue"),style="plain")
Sp <- ggs(as.mcmc(Normfit)[,c("Er", "gd", "gp","ue_ev[1]","ue_ev[2]")])
#DD <- as.matrix(as.mcmc(Normfit)[,c("e1", "gin", "gout")])
Sp0 <- Sp %>% as_tibble()
#%>% mutate(value = ifelse(Parameter == 'e1', 10*value, value))
levels(Sp0$Parameter) <- as.factor(c("E[0]","gamma[d]", "gamma[p]","Ue[1]", "Ue[2]"))
pair_wise_plot(Sp0)
pair_wise_plot <- function(s){
my_hist <- function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
stat_density_ridges(aes(y=0,fill=factor(..quantile..),alpha=factor(..quantile..)),geom = "density_ridges_gradient", calc_ecdf = TRUE, alpha=0.3,
quantiles = c(0.025, 0.25,  0.75, 0.975)) +
scale_fill_manual(name = "Probability", values = c("gray90", "gray70", "gray30",
"gray70","gray90" ))+
#     geom_histogram(bins = 10,fill="#bf812d",colour="#1F3552",...) +
#    geom_density(adjust = 1.5,fill="#bf812d",colour="#1F3552",...) +
theme_void() + theme( panel.grid.minor=element_blank(),
panel.grid.major = element_blank())
}
my_bin <- function(data, mapping, ..., low = "gray80", high = "gray15") {
# get the x and y data to use the other code
ggplot(data = data, mapping = mapping,linetype-"dashed",color="red") +
stat_density_2d(aes(fill =..level..,alpha =..level..),geom="polygon",...) +
#    stat_ellipse(type = "norm",level = 0.95,geom = "polygon",fill="#feb24c",...) +
#    stat_ellipse(type = "norm",level = 0.68,geom = "polygon",fill="#f03b20",...) +
#    geom_point() +
#   stat_ellipse(type = "t",level = 0.997,alpha=0.95,color="#dfc27d",...) +
#    stat_ellipse(type = "t",level = 0.95,alpha=0.95,color="red",...) +
#   stat_ellipse(type = "t",level = 0.68,alpha=0.95,color="red2",...) +
scale_x_continuous(breaks = scales::pretty_breaks(n = 4)) +
scale_y_continuous(breaks = scales::pretty_breaks(n = 4)) +
scale_fill_gradient(low = low, high = high) +
theme_bw() +
theme( text = element_text(size=60),axis.text = element_text(size=9.5),
axis.text.x = element_text(size=8, angle=25),
axis.text.y = element_text(size=8),
strip.text.x = element_text(colour = 'red',size = 20),
strip.text.y = element_text(colour = 'red',size = 20),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
}
ggs_pairs(s,
labeller = "label_parsed",
diag=list(continuous = my_hist),
upper = "blank",
lower = list(continuous = my_bin),
switch="both",
showStrips=FALSE
) }
pair_wise_plot(Sp0)
pair_wise_plot <- function(s){
my_hist <- function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
stat_density_ridges(aes(y=0,fill=factor(..quantile..),alpha=factor(..quantile..)),geom = "density_ridges_gradient", calc_ecdf = TRUE, alpha=0.3,
quantiles = c(0.025, 0.25,  0.75, 0.975)) +
scale_fill_manual(name = "Probability", values = c("gray90", "gray70", "gray30",
"gray70","gray90" ))+
#     geom_histogram(bins = 10,fill="#bf812d",colour="#1F3552",...) +
#    geom_density(adjust = 1.5,fill="#bf812d",colour="#1F3552",...) +
theme_void() + theme( panel.grid.minor=element_blank(),
panel.grid.major = element_blank())
}
my_bin <- function(data, mapping, ..., low = "gray80", high = "gray15") {
# get the x and y data to use the other code
ggplot(data = data, mapping = mapping,color="red") +
stat_density_2d(aes(fill =..level..,alpha =..level..),geom="polygon",...) +
#    stat_ellipse(type = "norm",level = 0.95,geom = "polygon",fill="#feb24c",...) +
#    stat_ellipse(type = "norm",level = 0.68,geom = "polygon",fill="#f03b20",...) +
#    geom_point() +
#   stat_ellipse(type = "t",level = 0.997,alpha=0.95,color="#dfc27d",...) +
#    stat_ellipse(type = "t",level = 0.95,alpha=0.95,color="red",...) +
#   stat_ellipse(type = "t",level = 0.68,alpha=0.95,color="red2",...) +
scale_x_continuous(breaks = scales::pretty_breaks(n = 4)) +
scale_y_continuous(breaks = scales::pretty_breaks(n = 4)) +
scale_fill_gradient(low = low, high = high) +
theme_bw() +
theme( text = element_text(size=60),axis.text = element_text(size=9.5),
axis.text.x = element_text(size=8, angle=25),
axis.text.y = element_text(size=8),
strip.text.x = element_text(colour = 'red',size = 20),
strip.text.y = element_text(colour = 'red',size = 20),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
}
ggs_pairs(s,
labeller = "label_parsed",
diag=list(continuous = my_hist),
upper = "blank",
lower = list(continuous = my_bin),
switch="both",
showStrips=FALSE
) }
pair_wise_plot(Sp0)
pair_wise_plot <- function(s){
my_hist <- function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
stat_density_ridges(aes(y=0,fill=factor(..quantile..),alpha=factor(..quantile..)),geom = "density_ridges_gradient", calc_ecdf = TRUE, alpha=0.3,
quantiles = c(0.025, 0.25,  0.75, 0.975)) +
scale_fill_manual(name = "Probability", values = c("gray90", "gray70", "gray30",
"gray70","gray90" ))+
#     geom_histogram(bins = 10,fill="#bf812d",colour="#1F3552",...) +
#    geom_density(adjust = 1.5,fill="#bf812d",colour="#1F3552",...) +
theme_void() + theme( panel.grid.minor=element_blank(),
panel.grid.major = element_blank())
}
my_bin <- function(data, mapping, ..., low = "gray80", high = "gray15") {
# get the x and y data to use the other code
ggplot(data = data, mapping = mapping) +
stat_density_2d(aes(fill =..level..,alpha =..level..),geom="polygon",...) +
#    stat_ellipse(type = "norm",level = 0.95,geom = "polygon",fill="#feb24c",...) +
#    stat_ellipse(type = "norm",level = 0.68,geom = "polygon",fill="#f03b20",...) +
#    geom_point() +
#   stat_ellipse(type = "t",level = 0.997,alpha=0.95,color="#dfc27d",...) +
#    stat_ellipse(type = "t",level = 0.95,alpha=0.95,color="red",...) +
#   stat_ellipse(type = "t",level = 0.68,alpha=0.95,color="red2",...) +
scale_x_continuous(breaks = scales::pretty_breaks(n = 4)) +
scale_y_continuous(breaks = scales::pretty_breaks(n = 4)) +
scale_fill_gradient(low = low, high = high) +
theme_bw() +
theme( text = element_text(size=60),axis.text = element_text(size=9.5),
axis.text.x = element_text(size=8, angle=25),
axis.text.y = element_text(size=8),
strip.text.x = element_text(colour = 'red',size = 20),
strip.text.y = element_text(colour = 'red',size = 20),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
}
ggs_pairs(s,
labeller = "label_parsed",
diag=list(continuous = my_hist),
upper = "blank",
lower = list(continuous = my_bin),
switch="both",
showStrips=TRUE
) }
pair_wise_plot(Sp0)
pair_wise_plot(Sp0)
# Case II
SpII <- ggs(as.mcmc(Normfit)[,c("Er_b","E0_b", "gd_b", "gp_b","ad_b","ap_b","ue_ev[1]","ue_ev[2]")])
#DD <- as.matrix(as.mcmc(Normfit)[,c("e1", "gin", "gout","ri","rf")])
Sp0II <- SpII %>% as_tibble()
#%>% mutate(value = ifelse(Parameter == 'e1', 10*value, value))
levels(Sp0II$Parameter) <- as.factor(c("a[d]","a[p]","E[0]","E[r]","gamma[d]", "gamma[p]","Ue[1]", "Ue[2]"))
pair_wise_plot(Sp0II)
install.packages("ggridges")
library(devtools)
install_github("clauswilke/ggridges")
pair_wise_plot <- function(s){
my_hist <- function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
stat_density_ridges(aes(y=0,fill=factor(..quantile..),alpha=factor(..quantile..)),geom = "density_ridges_gradient", calc_ecdf = TRUE, alpha=0.3,
quantiles = c(0.025, 0.25,  0.75, 0.975)) +
scale_fill_manual(name = "Probability", values = c("gray90", "gray70", "gray30",
"gray70","gray90" ))+
#     geom_histogram(bins = 10,fill="#bf812d",colour="#1F3552",...) +
#    geom_density(adjust = 1.5,fill="#bf812d",colour="#1F3552",...) +
theme_void() + theme( panel.grid.minor=element_blank(),
panel.grid.major = element_blank())
}
my_bin <- function(data, mapping, ..., low = "gray80", high = "gray15") {
# get the x and y data to use the other code
ggplot(data = data, mapping = mapping) +
stat_density_2d(aes(fill =..level..,alpha =..level..),geom="polygon",...) +
#    stat_ellipse(type = "norm",level = 0.95,geom = "polygon",fill="#feb24c",...) +
#    stat_ellipse(type = "norm",level = 0.68,geom = "polygon",fill="#f03b20",...) +
#    geom_point() +
#   stat_ellipse(type = "t",level = 0.997,alpha=0.95,color="#dfc27d",...) +
#    stat_ellipse(type = "t",level = 0.95,alpha=0.95,color="red",...) +
#   stat_ellipse(type = "t",level = 0.68,alpha=0.95,color="red2",...) +
scale_x_continuous(breaks = scales::pretty_breaks(n = 4)) +
scale_y_continuous(breaks = scales::pretty_breaks(n = 4)) +
scale_fill_gradient(low = low, high = high) +
theme_bw() +
theme( text = element_text(size=60),axis.text = element_text(size=9.5),
axis.text.x = element_text(size=8, angle=25),
axis.text.y = element_text(size=8),
strip.text.x = element_text(colour = 'red',size = 20),
strip.text.y = element_text(colour = 'red',size = 20),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
}
ggs_pairs(s,
labeller = "label_parsed",
diag=list(continuous = my_hist),
upper = "blank",
lower = list(continuous = my_bin),
switch="both",
showStrips=TRUE
) }
pair_wise_plot(Sp0II)
library("ggjoy", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
pair_wise_plot(Sp0II)
pair_wise_plot(Sp0II)
pair_wise_plot(Sp0II)
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(MCMCvis)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
source("..//..//auxiliar_functions/table_reaction.R")
## for block updating [we do not need to center predictor variables]
#load.module("glm")
load.module("nuclear")
######################################################################
## Read DATA
ensamble <- read.csv("ensamble.csv",header = T) %>%
mutate(Syst=replace(Syst,Syst==0.06,0.078))  %>% filter(E <= 0.5)
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
ik <- as.numeric(ensamble$invK)
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
# Literature
#  0.35779   # resonance energy
#  1.0085    # reduced width incoming
#  0.025425   # reduced width outgoing
pair_wise_plot(Sp0)
library("ggridges", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
pair_wise_plot(Sp0)
pair_wise_plot(Sp0II)
