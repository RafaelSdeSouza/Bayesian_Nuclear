LK2(xy[,1],xy[,2])
xy[,1]
sapply(LK2,xy)
sapply(xy,LK2)
sapply(LK2,xy)
LK2 <- function(x1,x2) {return(
likelihood(c(0.0912,x1,x2)))
}
sapply(xy,LK2)
xy <- expand.grid(x1=x1,x1=x2)
sapply(xy,LK2)
xy
sapply(xy$x1,xy$x1,LK2)
sapply(xy$x1,xy$x2,LK2)
require(GA)
SF<- function(x1, x2){
sfactorTdn(ER=0.0912,gi=x1,gf=x2)
}
x <- runif(100, 0.01, 0.3)
erry<- runif( 100, 0.01, 0.1)
y <- rnorm( 100, sfactorTdn(x,  0.0912, 2.93 , 0.0794), erry^2)
likelihood <- function(param){
"Likelihood function"
er = param[1]
gi = param[2]
gf = param[3]
LL = sum(((y - sfactorTdn(x,er,gi,gf))^2)/erry^2)
return(-log(LL))
}
LK2 <- function(x1,x2) {return(
likelihood(c(0.0912,x1,x2)))
}
xy <- expand.grid(x1=x1,x1=x2)
sapply(xy$x1,xy$x2,LK2)
x1 <- x2 <- seq(0.001, 20, by = 0.1)
slopevalues <- function(y){return(likelihood(c(0.0912,x1,x2)))}
slopevalues
x1
x2
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues
xy
xy <- expand.grid(x1=x1,x1=x2)
sapply(xy ,slopevalues)
sapply(c(x1,x2),slopevalues)
apply(c(x1,x2),slopevalues)
apply(xy,slopevalues)
apply(xy,1,slopevalues)
xy <- expand.grid(x1=x1,x2=x2)
apply(xy,2,slopevalues)
apply(xy,1,slopevalues)
x
xy <- expand.grid(x1=x1,x2=x2)
xy
apply(xy,1,slopevalues)
xy1
xy
xy[1,]
apply(xy,2,slopevalues)
slopevalues(xy)
slopevalues(xy[1,])
slopevalues(xy[,1],xy[,1])
slopevalues(xy[1,1],xy[1,1])
slopevalues(1,1)
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues(1,1)
y
require(nuclear)
y <- rnorm( 100, sfactorTdn(x,  0.0912, 2.93 , 0.0794), erry^2)
likelihood <- function(param){
"Likelihood function"
er = param[1]
gi = param[2]
gf = param[3]
LL = sum(((y - sfactorTdn(x,er,gi,gf))^2)/erry^2)
return(-log(LL))
}
LK2 <- function(x1,x2) {return(
likelihood(c(0.0912,x1,x2)))
}
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues(1,1)
slopevalues(xy[,1],xy[,2])
slopevalues(xy)
apply(xy,2,slopevalues)
xy
as.data.frame(xy)
xy <- as.data.frame(xy)
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
apply(xy,2,slopevalues)
Vectorize(slopevalues)
slopevalues <- Vectorize(slopevalues)
slopevalues(xy)
slopevalues
slopevalues(xy$x1,xy$x2)
f <- slopevalues(xy$x1,xy$x2)
persp3D(x1, x2, f, theta = 50, phi = 20)
persp3D(xy, f, theta = 50, phi = 20)
f
200*200
xy
persp3D(xy$x1,xy$x2, f, theta = 50, phi = 20)
xy$x1
xy$x2
z <- outer(x1, x2, slopevalues)
persp3D(x, y, z, theta = 50, phi = 20)
persp3D(x1, x2, z, theta = 50, phi = 20)
persp3D(x1, x2, z, theta = 50, phi = 30)
persp3D(x1, x2, z, theta = 80, phi = 30)
persp3D(x1, x2, z, theta = 80, phi = 20)
x1 <- x2 <- seq(0.001, 5, by = 0.1)
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues <- Vectorize(slopevalues)
z <- outer(x1, x2, slopevalues)
persp3D(x1, x2, z, theta = 80, phi = 20)
persp3D(x1, x2, z, theta = 60, phi = 20)
persp3D(x1, x2, z, theta = 60, phi = 60)
persp3D(x1, x2, z, theta = 60, phi = 25)
persp3D(x1, x2, z, theta = 160, phi = 25)
persp3D(x1, x2, z, theta = 140, phi = 25)
persp3D(x1, x2, z, theta = 120, phi = 25)
persp3D(x1, x2, z, theta = 110, phi = 25)
persp3D(x1, x2, z, theta = 90, phi = 25)
persp3D(x1, x2, z, theta = 100, phi = 25)
persp3D(x1, x2, z, theta = 100, phi = 35)
persp3D(x1, x2, z, theta = 100, phi = 15)
x1 <- x2 <- seq(0.001, 2, by = 0.01)
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues <- Vectorize(slopevalues)
z <- outer(x1, x2, slopevalues)
persp3D(x1, x2, z, theta = 100, phi = 15)
x1 <-  seq(0.001, 3.5, by = 0.01)
x2 <-  seq(0.001, 1, by = 0.01)
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues <- Vectorize(slopevalues)
z <- outer(x1, x2, slopevalues)
persp3D(x1, x2, z, theta = 100, phi = 15)
x1 <-  seq(0.001, 3.5, by = 0.01)
x2 <-  seq(0.001, 0.2, by = 0.01)
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues <- Vectorize(slopevalues)
z <- outer(x1, x2, slopevalues)
persp3D(x1, x2, z, theta = 100, phi = 15)
persp3D(x1, x2, z, theta = 60, phi = 15)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001, max = c(5, 5),
popSize = 50, maxiter = 100)
summary(GA)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001, max = c(5, 5),
popSize = 50, maxiter = 100)
ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001, max = c(5, 5),
popSize = 50, maxiter = 100)
ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001, max = c(5, 5),
popSize = 50, maxiter = 100)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001), max = c(5, 5),
popSize = 50, maxiter = 100)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001), max = c(5, 5),
popSize = 50, maxiter = 100)
summary(GA)
plot(GA)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001), max = c(5, 5),
popSize = 50, maxiter = 500)
summary(GA)
summary(GA)
plot(GA)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.0001, 0.0001), max = c(10, 10),
popSize = 100, maxiter = 1000)
summary(GA)
plot(GA)
summary(GA)
plot(GA)
filled.contour(x1, x2, z, color.palette = jet.colors)
filled.contour(x1, x2, z, color.palette = terrain.colors)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 200)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 100)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 100,key.axes=F)
levelplot(z~x1*x2, grid, cuts = 100)
require(lattice)
levelplot(z~x1*x2, grid, cuts = 100)
levelplot(z~x1*x2,  cuts = 100)
levelplot(z~x1*x2,  cuts = 100,color.palette = terrain.colors)
levelplot(z~x1*x2,  cuts = 100,color.palette = terrain.colors,region = TRUE)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 100)
filled.contour(x1, x2, z,nlevels = 100)
library(RColorBrewer)
darkcols <- brewer.pal(8, "Dark2")
filled.contour(x1, x2, z,color.palette=darkcols, nlevels = 100)
filled.contour(x1, x2, z, color.palette = darkcols ,nlevels = 100)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 100)
terrain.colors
filled.contour(x1, x2, z, color.palette=colorRampPalette(c('white','blue','yellow','red','darkred')),nlevels = 100)
15*30
15*40
14+24
38*10
2*3/2+1
1+1
2*3
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/He3dp/Real_data")
# 3Hedp analysis
#
# purpose: Real  DATA
#
# - 5 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorHe3dp(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
######################################################################
# preparation: remove all variables from the work space
#rm(list=ls())
set.seed(42)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
require(MCMCvis)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
source("..//..//auxiliar_functions/table_reaction.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
## Read DATA
ensamble <- read.csv("ensamble.csv",header = T) %>%
mutate(Syst=replace(Syst,Syst==0.06,0.078))  %>% filter(E <= 0.5)
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
ik <- as.numeric(ensamble$invK)
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
# Literature
#  0.35779   # resonance energy
#  1.0085    # reduced width incoming
#  0.025425   # reduced width outgoing
N <- nrow(ensamble)
obsy <- ensamble$S    # Response variable
obsx <-  ensamble$E   # Predictors
erry <- ensamble$Stat
set <- ensamble$dat
lab <- ensamble$invK
syst = c(0.03,unique(ensamble$Syst))
#syst <- syst[-3]
M <- 500
xx <- seq(min(obsx),max(obsx),length.out = M)
model.data <- list(obsy = obsy,    # Response variable
obsy2 = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble), # Sample size
syst = syst,
Nre = Nre,
re = re,
Nik = Nik,
ik  = ik,
M = M,
xx = xx,
ap  = 5,
ad = 6
)
# Conservative case
######################################################################
Model <- "model{
# LIKELIHOOD informative
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], E0, Er, gd2, gp2, ad, ap, ue[ik[i]]), pow(tau, -2))
res[i] <- obsy[i]-sfactor3Hedp(obsx[i], E0, Er, gd2, gp2, ad, ap,0)
}
# LIKELIHOOD broad
for (i in 1:N) {
obsy2[i] ~ dnorm(y_2[i], pow(erry[i], -2))
y_2[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i],  E0_b, Er_b, gd2_b, gp2_b, ad_b, ap_b, ue[ik[i]]),pow(tau_2, -2))
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,0)
mux0_2[j] <- sfactor3Hedp(xx[j], E0_b, Er_b, gd2_b, gp2_b, ad_b, ap_b,0)
DeltaM[j] <- (mux0[j] - mux0_2[j])/mux0[j]
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,pow(0.01,-2))T(0,)
}
# PRIORS 1
tau ~  dnorm(0, pow(1,-2))T(0,)
E0 ~   dnorm(0, pow(1,-2))T(0,)
Er <-  E0
gd2 ~  dnorm(0, pow(1,-2))T(0,)
gp2 ~ dnorm(0, pow(1,-2))T(0,)
#ad  ~  dnorm(6, pow(0.1,-2))T(0,)
#ap  ~  dnorm(5, pow(0.1,-2))T(0,)
#  Transform
gd <- sqrt(gd2)
gp <- sqrt(gp2)
ue_ev[1] <-1e6*ue[1]
ue_ev[2] <-1e6*ue[2]
gd_b <- sqrt(gd2_b)
gp_b <- sqrt(gp2_b)
tau_2  ~    dnorm(0, pow(1,-2))T(0,)
E0_b  ~  dnorm(0, pow(1,-2))T(0,)
Er_b  ~  dnorm(0, pow(1,-2))T(0,)
#Er_b   <- E0_b
gp2_b ~  dnorm(0, pow(1,-2))T(0,)
gd2_b  ~  dnorm(0, pow(1,-2))T(0,)
ad_b  ~ dnorm(5, pow(1,-2))T(0,)
ap_b  ~  dnorm(5, pow(1,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(Er = runif(1,0.4,0.5),  gd2 = runif(1,0.1,3), gp2 = runif(1,0.01,0.1)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("Er","gd", "gp","ue_ev","tau", "ad","ap","RSS","mux0","mux1","mux2","scale","DeltaM",
"E0_b","Er_b","gd_b", "gp_b","tau_2","ad_b","ap_b" ),
model.file  = textConnection(Model),
n.thin = 200,
n.chains = 3,
n.burnin = 750,
n.iter = 3000)
jagsresults(x = Normfit, params = c("Er","gd", "gp","ue","tau", "ad","ap","ue_ev"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
Normfit <- update(Normfit, n.burnin = 200,n.iter=10000)
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("Er","gd", "gp","ue_ev","tau", "ad","ap","RSS","mux0","mux1","mux2","scale","DeltaM",
"E0_b","Er_b","gd_b", "gp_b","tau_2","ad_b","ap_b" ),
model.file  = textConnection(Model),
n.thin = 200,
n.chains = 3,
n.burnin = 750,
n.iter = 3000)
jagsresults(x = Normfit, params = c("Er","gd", "gp","ue","tau", "ad","ap","ue_ev"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
Normfit <- update(Normfit, n.burnin = 200,n.iter=5000)
jagsresults(x = Normfit, params = c("Er","gd", "gp","ue","tau", "ad","ap","ue_ev"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
traplot(Normfit  ,c("Er","gd", "gp","ue"),style="plain")
# Conservative case
######################################################################
Model <- "model{
# LIKELIHOOD informative
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], E0, Er, gd2, gp2, ad, ap, ue[ik[i]]), pow(tau, -2))
res[i] <- obsy[i]-sfactor3Hedp(obsx[i], E0, Er, gd2, gp2, ad, ap,0)
}
# LIKELIHOOD broad
for (i in 1:N) {
obsy2[i] ~ dnorm(y_2[i], pow(erry[i], -2))
y_2[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i],  E0_b, Er_b, gd2_b, gp2_b, ad_b, ap_b, ue[ik[i]]),pow(tau_2, -2))
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,0)
mux0_2[j] <- sfactor3Hedp(xx[j], E0_b, Er_b, gd2_b, gp2_b, ad_b, ap_b,0)
DeltaM[j] <- (mux0[j] - mux0_2[j])/mux0[j]
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], E0, Er, gd2, gp2, ad, ap,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,pow(0.01,-2))T(0,)
}
# PRIORS 1
tau ~  dnorm(0, pow(1,-2))T(0,)
E0 ~   dnorm(0.5, pow(1,-2))T(0,)
Er <-  E0
gd2 ~  dnorm(1, pow(1,-2))T(0,)
gp2 ~ dnorm(0, pow(1,-2))T(0,)
#ad  ~  dnorm(6, pow(0.1,-2))T(0,)
#ap  ~  dnorm(5, pow(0.1,-2))T(0,)
#  Transform
gd <- sqrt(gd2)
gp <- sqrt(gp2)
ue_ev[1] <-1e6*ue[1]
ue_ev[2] <-1e6*ue[2]
gd_b <- sqrt(gd2_b)
gp_b <- sqrt(gp2_b)
tau_2  ~    dnorm(0, pow(1,-2))T(0,)
E0_b  ~  dnorm(0, pow(1,-2))T(0,)
Er_b  ~  dnorm(0, pow(1,-2))T(0,)
#Er_b   <- E0_b
gp2_b ~  dnorm(0, pow(1,-2))T(0,)
gd2_b  ~  dnorm(0, pow(1,-2))T(0,)
ad_b  ~ dnorm(5, pow(1,-2))T(0,)
ap_b  ~  dnorm(5, pow(1,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(Er = runif(1,0.4,0.5),  gd2 = runif(1,0.1,3), gp2 = runif(1,0.01,0.1)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
##require(runjags)
#m <- run.jags(model = Model,
#              monitor = c("e1","gin", "gout","ue","tau", "ri","rf",
#                          "e1_2","ex_2","gin_2", "gout_2","tau_2","ri_2","rf_2" ),
#              data = model.data,
#              n.chains = 10,
#              inits = inits,
#              burnin = 1000,
#              sample = 5000,
#              adapt = 2000
#)
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("Er","gd", "gp","ue_ev","tau", "ad","ap","RSS","mux0","mux1","mux2","scale","DeltaM",
"E0_b","Er_b","gd_b", "gp_b","tau_2","ad_b","ap_b" ),
model.file  = textConnection(Model),
n.thin = 200,
n.chains = 3,
n.burnin = 750,
n.iter = 3000)
jagsresults(x = Normfit, params = c("Er","gd", "gp","ue","tau", "ad","ap","ue_ev"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
Normfit <- update(Normfit, n.burnin = 200,n.iter=5000)
jagsresults(x = Normfit, params = c("Er","gd", "gp","ue","tau", "ad","ap","ue_ev"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
traplot(Normfit  ,c("Er","gd", "gp","ue"),style="plain")
Normfit <- update(Normfit, n.burnin = 10,n.iter=5000)
jagsresults(x = Normfit, params = c("Er","gd", "gp","ue","tau", "ad","ap","ue_ev"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
traplot(Normfit  ,c("Er","gd", "gp","ue"),style="plain")
Sp <- ggs(as.mcmc(Normfit)[,c("Er", "gd", "gp","ue_ev[1]","ue_ev[2]")])
#DD <- as.matrix(as.mcmc(Normfit)[,c("e1", "gin", "gout")])
Sp0 <- Sp %>% as_tibble()
#%>% mutate(value = ifelse(Parameter == 'e1', 10*value, value))
levels(Sp0$Parameter) <- as.factor(c("E[0]~(MeV)","gamma[d]~(MeV^{1/2})", "gamma[p]~(MeV^{1/2})","Ue[1]~(eV)", "Ue[2]~(eV)"))
pair_wise_plot(Sp0)
library("ggridges", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
pair_wise_plot(Sp0)
# Case II
SpII <- ggs(as.mcmc(Normfit)[,c("Er_b","E0_b", "gd_b", "gp_b","ad_b","ap_b","ue_ev[1]","ue_ev[2]")])
#DD <- as.matrix(as.mcmc(Normfit)[,c("e1", "gin", "gout","ri","rf")])
Sp0II <- SpII %>% as_tibble()
#%>% mutate(value = ifelse(Parameter == 'e1', 10*value, value))
#
Sp0II$Parameter <- ordered(Sp0II$Parameter, levels = c("Er_b","E0_b", "gd_b", "gp_b","ad_b","ap_b","ue_ev[1]","ue_ev[2]"))
levels(Sp0II$Parameter) <- as.factor(c("E[r]~(MeV)","E[0]~(MeV)","gamma[d]~(MeV^{1/2})", "gamma[p]~(MeV^{1/2})","a[d]~(fm)","a[p]~(fm)", "Ue[1]~(eV)", "Ue[2]~(eV)"))
pair_wise_plot(Sp0II)
Nsamp <- 2500
Tgrid <- c(0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009,0.010,0.011,0.012,
0.013,0.014,0.015,0.016,0.018,0.020,0.025,0.030,0.040,0.050,0.060,0.070,
0.080,0.090,0.100,0.110,0.120,0.130,0.140,0.150,0.160,0.180,0.200,0.250,0.300,
0.350,0.400,0.450,0.500,0.600,0.700,0.800,0.900,1.000,1.250,1.500,1.750,2.000,2.500,3.000,3.500,4.000,5.000,
6.000,7.000,8.000,9.000,10.000)
NA_I <-  table_reaction(Normfit,vars=c("Er", "gd", "gp","ad","ap"), N=1000)
NA_II <- table_reaction(Normfit,vars=c("Er_b","E0_b", "gd_b", "gp_b","ad_b","ap_b"),N=1000)
NA_I$Case <- "Case I"
NA_II$Case <- "Case II"
NA_total <-rbind(NA_I,NA_II)
write.csv(NA_I ,"NA_I.csv",row.names = F)
write.csv(NA_II ,"NA_II.csv",row.names = F)
pair_wise_plot(Sp0)
Sp <- ggs(as.mcmc(Normfit)[,c("Er", "gd", "gp","ue_ev[1]","ue_ev[2]")])
#DD <- as.matrix(as.mcmc(Normfit)[,c("e1", "gin", "gout")])
pair_wise_plot(Sp0)
jagsresults(x = Normfit, params = c("Er","gd", "gp","ue","tau", "ad","ap","ue_ev"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
jagsresults(x = Normfit , params = c("E0_b","Er_b","gd_b", "gp_b","tau_2","ad_b","ap_b","ue_ev"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
