sfactorTdn(ER=0.0912,gi=x1,gf=x2)
}
x <- runif(100, 0.01, 0.3)
erry<- runif( 100, 0.01, 0.1)
y <- rnorm( 100, sfactorTdn(x,  0.0912, 2.93 , 0.0794), erry^2)
likelihood <- function(param){
"Likelihood function"
er = param[1]
gi = param[2]
gf = param[3]
LL = sum(((y - sfactorTdn(x,er,gi,gf))^2)/erry^2)
return(-log(LL))
}
LK2 <- function(x1,x2) {return(
likelihood(c(0.0912,x1,x2)))
}
xy <- expand.grid(x1=x1,x1=x2)
sapply(xy$x1,xy$x2,LK2)
x1 <- x2 <- seq(0.001, 20, by = 0.1)
slopevalues <- function(y){return(likelihood(c(0.0912,x1,x2)))}
slopevalues
x1
x2
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues
xy
xy <- expand.grid(x1=x1,x1=x2)
sapply(xy ,slopevalues)
sapply(c(x1,x2),slopevalues)
apply(c(x1,x2),slopevalues)
apply(xy,slopevalues)
apply(xy,1,slopevalues)
xy <- expand.grid(x1=x1,x2=x2)
apply(xy,2,slopevalues)
apply(xy,1,slopevalues)
x
xy <- expand.grid(x1=x1,x2=x2)
xy
apply(xy,1,slopevalues)
xy1
xy
xy[1,]
apply(xy,2,slopevalues)
slopevalues(xy)
slopevalues(xy[1,])
slopevalues(xy[,1],xy[,1])
slopevalues(xy[1,1],xy[1,1])
slopevalues(1,1)
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues(1,1)
y
require(nuclear)
y <- rnorm( 100, sfactorTdn(x,  0.0912, 2.93 , 0.0794), erry^2)
likelihood <- function(param){
"Likelihood function"
er = param[1]
gi = param[2]
gf = param[3]
LL = sum(((y - sfactorTdn(x,er,gi,gf))^2)/erry^2)
return(-log(LL))
}
LK2 <- function(x1,x2) {return(
likelihood(c(0.0912,x1,x2)))
}
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues(1,1)
slopevalues(xy[,1],xy[,2])
slopevalues(xy)
apply(xy,2,slopevalues)
xy
as.data.frame(xy)
xy <- as.data.frame(xy)
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
apply(xy,2,slopevalues)
Vectorize(slopevalues)
slopevalues <- Vectorize(slopevalues)
slopevalues(xy)
slopevalues
slopevalues(xy$x1,xy$x2)
f <- slopevalues(xy$x1,xy$x2)
persp3D(x1, x2, f, theta = 50, phi = 20)
persp3D(xy, f, theta = 50, phi = 20)
f
200*200
xy
persp3D(xy$x1,xy$x2, f, theta = 50, phi = 20)
xy$x1
xy$x2
z <- outer(x1, x2, slopevalues)
persp3D(x, y, z, theta = 50, phi = 20)
persp3D(x1, x2, z, theta = 50, phi = 20)
persp3D(x1, x2, z, theta = 50, phi = 30)
persp3D(x1, x2, z, theta = 80, phi = 30)
persp3D(x1, x2, z, theta = 80, phi = 20)
x1 <- x2 <- seq(0.001, 5, by = 0.1)
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues <- Vectorize(slopevalues)
z <- outer(x1, x2, slopevalues)
persp3D(x1, x2, z, theta = 80, phi = 20)
persp3D(x1, x2, z, theta = 60, phi = 20)
persp3D(x1, x2, z, theta = 60, phi = 60)
persp3D(x1, x2, z, theta = 60, phi = 25)
persp3D(x1, x2, z, theta = 160, phi = 25)
persp3D(x1, x2, z, theta = 140, phi = 25)
persp3D(x1, x2, z, theta = 120, phi = 25)
persp3D(x1, x2, z, theta = 110, phi = 25)
persp3D(x1, x2, z, theta = 90, phi = 25)
persp3D(x1, x2, z, theta = 100, phi = 25)
persp3D(x1, x2, z, theta = 100, phi = 35)
persp3D(x1, x2, z, theta = 100, phi = 15)
x1 <- x2 <- seq(0.001, 2, by = 0.01)
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues <- Vectorize(slopevalues)
z <- outer(x1, x2, slopevalues)
persp3D(x1, x2, z, theta = 100, phi = 15)
x1 <-  seq(0.001, 3.5, by = 0.01)
x2 <-  seq(0.001, 1, by = 0.01)
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues <- Vectorize(slopevalues)
z <- outer(x1, x2, slopevalues)
persp3D(x1, x2, z, theta = 100, phi = 15)
x1 <-  seq(0.001, 3.5, by = 0.01)
x2 <-  seq(0.001, 0.2, by = 0.01)
slopevalues <- function(x1,x2){return(likelihood(c(0.0912,x1,x2)))}
slopevalues <- Vectorize(slopevalues)
z <- outer(x1, x2, slopevalues)
persp3D(x1, x2, z, theta = 100, phi = 15)
persp3D(x1, x2, z, theta = 60, phi = 15)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001, max = c(5, 5),
popSize = 50, maxiter = 100)
summary(GA)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001, max = c(5, 5),
popSize = 50, maxiter = 100)
ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001, max = c(5, 5),
popSize = 50, maxiter = 100)
ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001, max = c(5, 5),
popSize = 50, maxiter = 100)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001), max = c(5, 5),
popSize = 50, maxiter = 100)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001), max = c(5, 5),
popSize = 50, maxiter = 100)
summary(GA)
plot(GA)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.001, 0.001), max = c(5, 5),
popSize = 50, maxiter = 500)
summary(GA)
summary(GA)
plot(GA)
GA <- ga(type = "real-valued", fitness =  function(x) -slopevalues(x[1],x[2]),
min = c(0.0001, 0.0001), max = c(10, 10),
popSize = 100, maxiter = 1000)
summary(GA)
plot(GA)
summary(GA)
plot(GA)
filled.contour(x1, x2, z, color.palette = jet.colors)
filled.contour(x1, x2, z, color.palette = terrain.colors)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 200)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 100)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 100,key.axes=F)
levelplot(z~x1*x2, grid, cuts = 100)
require(lattice)
levelplot(z~x1*x2, grid, cuts = 100)
levelplot(z~x1*x2,  cuts = 100)
levelplot(z~x1*x2,  cuts = 100,color.palette = terrain.colors)
levelplot(z~x1*x2,  cuts = 100,color.palette = terrain.colors,region = TRUE)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 100)
filled.contour(x1, x2, z,nlevels = 100)
library(RColorBrewer)
darkcols <- brewer.pal(8, "Dark2")
filled.contour(x1, x2, z,color.palette=darkcols, nlevels = 100)
filled.contour(x1, x2, z, color.palette = darkcols ,nlevels = 100)
filled.contour(x1, x2, z, color.palette = terrain.colors,nlevels = 100)
terrain.colors
filled.contour(x1, x2, z, color.palette=colorRampPalette(c('white','blue','yellow','red','darkred')),nlevels = 100)
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/He3dp/Real_data")
# 3Hedp analysis
#
# purpose: Real  DATA
#
# - 5 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorHe3dp(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
######################################################################
# preparation: remove all variables from the work space
rm(list=ls())
set.seed(123)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
## Read DATA
ensamble <- read.csv("ensamble.csv",header = T) %>%
mutate(Syst=replace(Syst,Syst==0.06,0.078))
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
ik <- as.numeric(ensamble$invK)
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
# Literature
#  0.35779   # resonance energy
#  1.0085    # reduced width incoming
#  0.025425   # reduced width outgoing
N <- nrow(ensamble)
obsy <- ensamble$S    # Response variable
obsx <-  ensamble$E   # Predictors
erry <- ensamble$Stat
set <- ensamble$dat
lab <- ensamble$invK
syst = c(0.03,unique(ensamble$Syst))
#syst <- syst[-3]
M <- 500
xx <- seq(min(obsx),max(obsx),length.out = M)
model.data <- list(obsy = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble), # Sample size
syst = syst,
Nre = Nre,
re = re,
Nik = Nik,
ik  = ik,
M = M,
xx = xx
)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], e1, ex, gin, gout,ri,rf,ue[ik[i]]),pow(tau, -2))
res[i] <- obsy[i]-sfactor3Hedp(obsx[i], e1,ex, gin, gout,ri,rf,0)
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], e1,ex, gin, gout,ri,rf,0)
yx0[j] ~ dnorm(mux0[j],pow(tau,-2))
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], e1, ex,gin, gout,ri,rf,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], e1,ex, gin, gout,ri,rf,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,1e3)T(0,)
}
# PRIORS
# Wigner limit: wl = hbar^2/(m_red a_c^2) = 41.80159/(M_red a_c^2)
#
# deuteron channel: wl_d = 41.80159/(1.207357 a_c^2) = 34.6224/a_c^2
# neutron channel:  wl_n = 41.80159/(0.805597 a_c^2) = 51.8889/a_c^2
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
tau ~  dt(0, pow(5,-2), 1)T(0,)
e1 ~  dnorm(0,0.1)T(0,)
ex ~  dnorm(0,0.1)T(0,)
rf ~  dnorm(5,5)T(0,)
ri ~  dnorm(5,5)T(0,)
gin ~  dnorm(1,pow(0.25,-2))T(0,)
gout ~ dnorm(0,pow(0.05,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.15,1),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("e1", "gin", "gout","ue","tau", "ri","rf","RSS","mux0","mux1","mux2","scale"),
model.file  = textConnection(Model),
n.thin = 5,
adapt=10000,
n.chains = 3,
n.burnin = 10000,
n.iter = 30000)
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("e1", "ex","gin", "gout","ue","tau", "ri","rf","RSS","mux0","mux1","mux2","scale"),
model.file  = textConnection(Model),
n.thin = 5,
n.chains = 3,
n.burnin = 10000,
n.iter = 30000)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], e1, ex, gin, gout,ri,rf,ue[ik[i]]),pow(tau, -2))
res[i] <- obsy[i]-sfactor3Hedp(obsx[i], e1,ex, gin, gout,ri,rf,0)
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], e1,ex, gin, gout,ri,rf,0)
yx0[j] ~ dnorm(mux0[j],pow(tau,-2))
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], e1, ex,gin, gout,ri,rf,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], e1,ex, gin, gout,ri,rf,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,1e3)T(0,)
}
# PRIORS
# Wigner limit: wl = hbar^2/(m_red a_c^2) = 41.80159/(M_red a_c^2)
#
# deuteron channel: wl_d = 41.80159/(1.207357 a_c^2) = 34.6224/a_c^2
# neutron channel:  wl_n = 41.80159/(0.805597 a_c^2) = 51.8889/a_c^2
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
tau ~  dt(0, pow(5,-2), 1)T(0,)
e1 ~  dnorm(0,0.1)T(0,)
ex ~  dnorm(1,0.1)T(0,)
rf ~  dnorm(5,5)T(0,)
ri ~  dnorm(5,5)T(0,)
gin ~  dnorm(1,pow(0.25,-2))T(0,)
gout ~ dnorm(0,pow(0.05,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.15,1),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("e1", "ex","gin", "gout","ue","tau", "ri","rf","RSS","mux0","mux1","mux2","scale"),
model.file  = textConnection(Model),
n.thin = 5,
n.chains = 3,
n.burnin = 10000,
n.iter = 30000)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], e1, ex, gin, gout,ri,rf,ue[ik[i]]),pow(tau, -2))
res[i] <- obsy[i]-sfactor3Hedp(obsx[i], e1,ex, gin, gout,ri,rf,0)
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], e1,ex, gin, gout,ri,rf,0)
yx0[j] ~ dnorm(mux0[j],pow(tau,-2))
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], e1, ex,gin, gout,ri,rf,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], e1,ex, gin, gout,ri,rf,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,1e3)T(0,)
}
# PRIORS
# Wigner limit: wl = hbar^2/(m_red a_c^2) = 41.80159/(M_red a_c^2)
#
# deuteron channel: wl_d = 41.80159/(1.207357 a_c^2) = 34.6224/a_c^2
# neutron channel:  wl_n = 41.80159/(0.805597 a_c^2) = 51.8889/a_c^2
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
tau ~  dt(0, pow(5,-2), 1)T(0,)
e1 ~  dt(0, pow(5,-2), 1)T(0,)
ex ~  dt(0, pow(5,-2), 1)T(0,)
rf ~  dnorm(5,5)T(0,)
ri ~  dnorm(5,5)T(0,)
gin ~  dnorm(1,pow(0.25,-2))T(0,)
gout ~ dnorm(0,pow(0.05,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.15,1),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters.to.save  = c("e1", "ex","gin", "gout","ue","tau", "ri","rf","RSS","mux0","mux1","mux2","scale"),
model.file  = textConnection(Model),
n.thin = 5,
n.chains = 3,
n.burnin = 10000,
n.iter = 30000)
jagsresults(x = Normfit , params = c("e1", "gin", "gout","ue","tau","ri","rf"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
jagsresults(x = Normfit , params = c("e1", "ex","gin", "gout","ue","tau","ri","rf"),probs = c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
traplot(Normfit  ,c("e1", "gin", "gout"),style="plain")
traplot(Normfit  ,c("e1", "ex","gin", "gout","ue","tau","ri","rf"),style="plain")
y <- jagsresults(x=Normfit , params=c('mux1'),probs=c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
x <- xx
gdata <- data.frame(x =xx, mean = y[,"mean"],lwr1=y[,"25%"],lwr2=y[,"2.5%"],lwr3=y[,"0.5%"],upr1=y[,"75%"],
upr2=y[,"97.5%"],upr3=y[,"99.5%"])
gobs <- data.frame(obsx,obsy,erry,set,lab)
gobs$set <- as.factor(gobs$set)
y2 <- jagsresults(x=Normfit , params=c('mux2'),probs=c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
gdata2 <- data.frame(x =xx, mean = y2[,"mean"],lwr1=y2[,"25%"],lwr2=y2[,"2.5%"],lwr3=y2[,"0.5%"],upr1=y2[,"75%"],
upr2=y2[,"97.5%"],upr3=y2[,"99.5%"])
y0 <- jagsresults(x=Normfit , params=c('mux0'),probs=c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
gdata0 <- data.frame(x =xx, mean = y0[,"mean"],lwr1=y0[,"25%"],lwr2=y0[,"2.5%"],lwr3=y0[,"0.5%"],upr1=y0[,"75%"],
upr2=y0[,"97.5%"],upr3=y0[,"99.5%"])
ggplot(gobs,aes(x=obsx,y=obsy))+
geom_rect(aes(xmin=0.045, xmax=0.356, ymin=-1, ymax=22), fill="gray90",alpha=0.4) +
# red
geom_ribbon(data=gdata2,aes(x=xx,ymin=lwr3, ymax=upr3,y= NULL),fill=c("#fdd0a2"),show.legend=FALSE)+
geom_ribbon(data=gdata2,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("#fdae6b"),show.legend=FALSE) +
geom_ribbon(data=gdata2,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("#d94801"),show.legend=FALSE) +
geom_ribbon(data=gdata,aes(x=xx,ymin=lwr3, ymax=upr3,y= NULL),fill=c("gray95"),show.legend=FALSE)+
geom_ribbon(data=gdata,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("gray75"),show.legend=FALSE) +
geom_ribbon(data=gdata,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("gray55"),show.legend=FALSE) +
#  Bare
geom_ribbon(data=gdata0,aes(x=xx,ymin=lwr3, ymax=upr3,y= NULL),fill=c("#dadaeb"),show.legend=FALSE)+
geom_ribbon(data=gdata0,aes(x=xx,ymin=lwr2, ymax=upr2,y=NULL),  fill = c("#9e9ac8"),show.legend=FALSE) +
geom_ribbon(data=gdata0,aes(x=xx,ymin=lwr1, ymax=upr1,y=NULL),fill=c("#984ea3"),show.legend=FALSE) +
#
#
geom_point(data=gobs,aes(x=obsx,y=obsy,group=set,color=set,shape=set),size=2.75,alpha=0.75)+
geom_errorbar(show.legend=FALSE,data=gobs,aes(x=obsx,y=obsy,ymin=obsy-erry,ymax=obsy+erry,group=set,color=set),
width=0.01,alpha=0.4)+
#  geom_line(data=gdata,aes(x=xx,y=mean),linetype="dashed",size=0.75,show.legend=FALSE)+
#  geom_line(data=gdata2,aes(x=xx,y=mean),linetype="dashed",size=0.75,show.legend=FALSE)+
scale_colour_manual(name="",values=c("gray20","#7f0000","#7f0000","gray20","gray20",
"gray20","gray20"))+
scale_shape_manual(values=c(0,19,8,10,4,17,3),name="")+
coord_cartesian(xlim=c(5e-3,0.85),ylim=c(0,20)) +
theme_bw() + xlab("Energy (MeV)") + ylab("S-Factor (MeV b)") +
scale_x_log10()  +
annotation_logticks(sides = "b") +
annotation_logticks(base=2.875,sides = "l") +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position = c(0.9,0.675),
legend.background = element_rect(colour = "white", fill = "white"),
legend.text = element_text(size=14,colour = set),
plot.background = element_rect(colour = "white", fill = "white"),
panel.background = element_rect(colour = "white", fill = "white"),
legend.key = element_rect(colour = "white", fill = "white"),
axis.title = element_text(size=18.5),
axis.text  = element_text(size=13),
axis.ticks = element_line(size = 0.75),
axis.line = element_line(size = 0.5, linetype = "solid"))
