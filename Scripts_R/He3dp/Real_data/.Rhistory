N = nrow(ensamble), # Sample size
syst = syst,
Nre = Nre,
re = re,
Nik = Nik,
ik  = ik,
M = M,
xx = xx,
b0 =  c(0.5,0.5,5,5),
B0 = diag(1, 4)
)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], e1, theta[1], theta[2],theta[3],theta[4],ue[ik[i]]),pow(tau, -2))
#y[i] <- scale[re[i]]*sfactor3Hedp(obsx[i], e1, g[1], g[2])
}
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], e1, theta[1], theta[2],theta[3],theta[4],0)
yx0[j] ~ dnorm(mux0[j],pow(tau,-2))
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], e1, theta[1], theta[2],theta[3],theta[4],ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], e1, theta[1], theta[2],theta[3],theta[4],ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,1e3)T(0,)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
tau ~  dnorm(0,0.1)T(0,)
e1 ~   dnorm(0,0.1)T(0,)
theta ~ dmnorm(b0[],B0[,])I(c(0,0,0,0),)
#gin ~ dnorm(0,1)
#gout ~ dnorm(0,0.1)T(0,)
#rf ~ dnorm(5,5)T(0,)
#ri ~  dnorm(5,5)T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.15,1),theta=c(runif(4,0.01,10))) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "theta","ue","tau","mux0","mux1","mux2","scale"),
model = textConnection(Model),
n.thin = 5,
n.chains = 3,
n.burnin = 2500,
n.iter = 5000)
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/He3dp/Real_data")
setwd("~/Documents/GitHub/JAGS_UNC/Scripts_R/He3dp/Real_data")
# 3Hedp analysis
#
# purpose: Real  DATA
#
# - 5 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorHe3dp(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
######################################################################
# preparation: remove all variables from the work space
rm(list=ls())
set.seed(123)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import packages
library(rjags);library(R2jags);library(mcmcplots)
require(RcppGSL);require(ggplot2);require(ggthemes)
require(nuclear);library(magrittr);library(wesanderson)
library(dplyr);require(ggsci);require(ggmcmc);require(plyr);library(latex2exp)
source("..//..//auxiliar_functions/jagsresults.R")
source("..//..//auxiliar_functions/theme_rafa.R")
source("..//..//auxiliar_functions/pair_wise_plot.R")
source("..//..//auxiliar_functions/Gamma3Hedp.R")
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
######################################################################
## Read DATA
ensamble <- read.csv("ensamble.csv",header = T) %>%
mutate(Syst=replace(Syst,Syst==0.06,0.078))
re <- as.numeric(ensamble$dat)
Nre <- length(unique(ensamble$dat))
ik <- as.numeric(ensamble$invK)
Nik <- length(unique(ensamble$invK))
# Radius
# r_i = 6
# r_f = 5
# Literature
#  0.35779   # resonance energy
#  1.0085    # reduced width incoming
#  0.025425   # reduced width outgoing
N <- nrow(ensamble)
obsy <- ensamble$S    # Response variable
obsx <-  ensamble$E   # Predictors
erry <- ensamble$Stat
set <- ensamble$dat
lab <- ensamble$invK
syst = c(0.03,unique(ensamble$Syst))
#syst <- syst[-3]
M <- 500
xx <- seq(min(obsx),max(obsx),length.out = M)
model.data <- list(obsy = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble), # Sample size
syst = syst,
Nre = Nre,
re = re,
Nik = Nik,
ik  = ik,
M = M,
xx = xx
)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], e1, gin, gout,ri,rf,ue[ik[i]]),pow(tau, -2))
#y[i] <- scale[re[i]]*sfactor3Hedp(obsx[i], e1, gin, gout)
}
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,0)
yx0[j] ~ dnorm(mux0[j],pow(tau,-2))
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,1e3)T(0,)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
tau ~  dnorm(0,0.1)T(0,)
e1 ~   dnorm(0,0.1)T(0,)
gin ~ dnorm(0,1)T(0,)
gout ~ dnorm(lam*gin,0.1)T(0,)
lam ~ dnorm(0,0.01)
rf ~ dnorm(5,5)T(0,)
ri ~  dnorm(5,5)T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.15,1),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout","ue","tau", "ri","rf","mux0","mux1","mux2","scale"),
model = textConnection(Model),
n.thin = 5,
n.chains = 3,
n.burnin = 5000,
n.iter = 10000)
jagsresults(x=Normfit , params=c("e1", "gin", "gout","ue","tau","ri","rf"),probs=c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
traplot(Normfit  ,c("e1", "gin", "gout","ri","rf"),style="plain")
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], e1, gin, gout,ri,rf,ue[ik[i]]),pow(tau, -2))
#y[i] <- scale[re[i]]*sfactor3Hedp(obsx[i], e1, gin, gout)
}
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,0)
yx0[j] ~ dnorm(mux0[j],pow(tau,-2))
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,1e3)T(0,)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
tau ~  dnorm(0,0.1)T(0,)
e1 ~   dnorm(0,0.1)T(0,)
gout ~ dnorm(0,1)T(0,)
gin ~ dnorm(lam*gout,1)T(0,)
lam ~ dnorm(0,0.01)
rf ~ dnorm(5,5)T(0,)
ri ~  dnorm(5,5)T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.15,1),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
inits <- function () { list(e1 = runif(1,0.15,1),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout","ue","tau", "ri","rf","mux0","mux1","mux2","scale"),
model = textConnection(Model),
n.thin = 5,
n.chains = 3,
n.burnin = 2500,
n.iter = 5000)
jagsresults(x=Normfit , params=c("e1", "gin", "gout","ue","tau","ri","rf"),probs=c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
traplot(Normfit  ,c("e1", "gin", "gout","ri","rf"),style="plain")
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], e1, gin, gout,ri,rf,ue[ik[i]]),pow(tau, -2))
#y[i] <- scale[re[i]]*sfactor3Hedp(obsx[i], e1, gin, gout)
}
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,0)
yx0[j] ~ dnorm(mux0[j],pow(tau,-2))
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,1e3)T(0,)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
tau ~  dnorm(0,0.1)T(0,)
e1 ~   dnorm(0,0.1)T(0,)
gout ~ dnorm(0,1)T(0,)
gin ~ dnorm(lam*gout,1)T(0,)
lam ~ dnorm(0,0.01)
rf ~ dnorm(5,5)T(3,)
ri ~  dnorm(5,5)T(3,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.15,1),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout","ue","tau", "ri","rf","mux0","mux1","mux2","scale"),
model = textConnection(Model),
n.thin = 5,
n.chains = 3,
n.burnin = 2500,
n.iter = 5000)
jagsresults(x=Normfit , params=c("e1", "gin", "gout","ue","tau","ri","rf"),probs=c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
traplot(Normfit  ,c("e1", "gin", "gout","ri","rf"),style="plain")
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], e1, gin, gout,ri,rf,ue[ik[i]]),pow(tau, -2))
#y[i] <- scale[re[i]]*sfactor3Hedp(obsx[i], e1, gin, gout)
}
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,0)
yx0[j] ~ dnorm(mux0[j],pow(tau,-2))
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,1e3)T(0,)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
tau ~  dnorm(0,0.1)T(0,)
e1 ~   dnorm(0,0.1)T(0,)
gout ~ dnorm(0.5,tau.g)T(0,1)
gin ~ dnorm(1,tau.g)T(0,)
tau.g ~ dunif(0.01,1)
rf ~ dnorm(5,5)T(3,7)
ri ~  dnorm(5,5)T(3,7)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.15,1),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout","ue","tau", "ri","rf","mux0","mux1","mux2","scale"),
model = textConnection(Model),
n.thin = 5,
n.chains = 3,
n.burnin = 2500,
n.iter = 5000)
jagsresults(x=Normfit , params=c("e1", "gin", "gout","ue","tau","ri","rf"),probs=c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], e1, gin, gout,ri,rf,ue[ik[i]]),pow(tau, -2))
#y[i] <- scale[re[i]]*sfactor3Hedp(obsx[i], e1, gin, gout)
}
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,0)
yx0[j] ~ dnorm(mux0[j],pow(tau,-2))
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,1e3)T(0,)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
tau ~  dnorm(0,0.1)T(0,)
e1 ~   dnorm(0,0.1)T(0,)
gout ~ dnorm(0.5,0.1)T(0,1)
gin ~ dnorm(1,1)T(0,)
rf ~ dnorm(5,5)T(3,7)
ri ~  dnorm(5,5)T(3,7)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.15,1),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout","ue","tau", "ri","rf","mux0","mux1","mux2","scale"),
model = textConnection(Model),
n.thin = 5,
n.chains = 3,
n.burnin = 2500,
n.iter = 5000)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(scale[re[i]]*sfactor3Hedp(obsx[i], e1, gin, gout,ri,rf,ue[ik[i]]),pow(tau, -2))
#y[i] <- scale[re[i]]*sfactor3Hedp(obsx[i], e1, gin, gout)
}
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,0)
yx0[j] ~ dnorm(mux0[j],pow(tau,-2))
# No inverse Kinematics
mux1[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,ue[1])
yx1[j] ~ dnorm(mux1[j],pow(tau,-2))
# With inverse Kinematics
mux2[j] <- sfactor3Hedp(xx[j], e1, gin, gout,ri,rf,ue[2])
yx2[j] ~ dnorm(mux1[j],pow(tau,-2))
}
for (k in 1:Nre){
scale[k] ~ dlnorm(log(1.0),1/log(1+pow(syst[k],2)))
}
for (z in 1:Nik){
ue[z] ~ dnorm(0,1e3)T(0,)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
tau ~  dnorm(0,0.1)T(0,)
e1 ~   dnorm(0,0.1)T(0,)
gout ~ dnorm(0.5,0.1)T(0,)
gin ~ dnorm(1,1)T(0,)
rf ~ dnorm(5,5)T(3,7)
ri ~  dnorm(5,5)T(3,7)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.15,1),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout","ue","tau", "ri","rf","mux0","mux1","mux2","scale"),
model = textConnection(Model),
n.thin = 5,
n.chains = 3,
n.burnin = 2500,
n.iter = 5000)
jagsresults(x=Normfit , params=c("e1", "gin", "gout","ue","tau","ri","rf"),probs=c(0.005,0.025, 0.25, 0.5, 0.75, 0.975,0.995))
