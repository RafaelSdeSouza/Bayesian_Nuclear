#include "sfactorTdn.h"#include <config.h>#include <cmath>// isScalar()#include <util/dim.h>#include <iostream>#include <fstream>#include <string>#include <stdlib.h>using std::vector;namespace jags {namespace nuclear {/** * @short Matrix- or array-valued function * * Array-valued functions are the most general class of function. The * arguments of an array-valued function, and the value may be a * scalar, vector, or array. * * We use ArrayFunction here because there is no more specific class * that accepts scalars and returns vectors */    sfactorTdn::sfactorTdn()	: ArrayFunction("sfactorTdn",3)    {    }/** * Evaluates the function. * * @param value array of doubles which contains the result of * the evaluation on exit * @param args Vector of arguments. * @param dims Respective dimensions of each element of args. */    void    sfactorTdn::evaluate (double *value, 			std::vector<double const *> const &args,			std::vector<std::vector<unsigned int> > const &dims) const    {	 // parameters to be written to the fortran input file    double e1 = args[0][0];    double gin = args[1][0];    double gout = args[2][0];    // open the fortran input file for writing    std::ofstream paramfile;    paramfile.open ("tdn.in");paramfile <<  e1 << "\n";paramfile <<  gin << "\n";paramfile <<  gout << "\n";paramfile.close();//////////////////////////////////////////////////////////////////////// now that the parameter file is written, run the fortran executable//////////////////////////////////////////////////////////////////////int retcode = system("./tdn");//read the fortran executable's output file:std::string line;std::ifstream ifile ("tdn.out");if (ifile.is_open()) {  // skip the first 14 lines   //      for(int i = 0; i < 14; i++){   //          getline(ifile, line);   //      }        // read 1000 lines.  Each line contains two numbers separated by a space.        // `value` is a 1-D array, so we need to do some tricky indexing.        // IMPORTANT: JAGS stores arrays in column-major order, so entire columns        // are stored in contiguous memory.  Unlike C, which is row-major.        // You will tear your hair out if you don't know this.        for(int i = 0; i < 1000; i++){            ifile >> value[i] >> value[i+1000];        }        ifile.close();    }    else {        // it's really bad if this happens        // TODO: figure out how to throw an error        std::cout << "Unable to open file";} }/** * Checks whether dimensions of the function parameters are correct. * * @param dims Vector of length npar denoting the dimensions of * the parameters, with any redundant dimensions dropped. */boolsfactorTdn::checkParameterDim(std::vector<std::vector<unsigned int> > const &dims) const{    // the three arguments should be scalars    return isScalar(dims[0]) && isScalar(dims[1]) && isScalar(dims[2]);}/** * Checks whether the parameter values lie in the domain of the * function. The default implementation returns true. */boolsfactorTdn::checkParameterValue(std::vector<double const *> const &args,                             std::vector<std::vector<unsigned int> > const &dims) const    {        // TODO: should any parameters be eg strictly positive?        return true;}/** * Calculates what the dimension of the return value should be, * based on the arguments. * * @param dims Vector of Indices denoting the dimensions of the     * parameters. This vector must return true when passed to     * checkParameterDim.     *     * @param values Vector of pointers to parameter values.     */    std::vector<unsigned int>    sfactorTdn::dim(std::vector <std::vector<unsigned int> > const &dims,                 std::vector <double const *> const &values) const    {        // the size of the table that the fortran code calculates is 1000 row by 2 col        vector<unsigned int> ans(2);        ans[0] = 1000;        ans[1] = 2;        return ans;} }}