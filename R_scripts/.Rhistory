require(rjags)
load.module("wiener")
install.packages("mclust")
setwd("~/Documents/GitHub/JAGS_UNC/R_scripts")
# tdn analysis
#
# purpose: ARTIFICIAL DATA
#
# - 3 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorTdn_fast(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
# Fortran code tdn_plot.f is needed in this R script for plotting the
# S-factor only
#
######################################################################
# preparation: remove all variables from the work space
rm(list=ls())
#set.seed(123)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
## ARTIFICIAL DATA GENERATION
N <- 50
obsx1 <- log(runif(N, exp(0.0), exp(0.2)))
res <- vector()
obsy1 <- vector()
errobsy1 <- vector()
# Barker values:
# Er  = 0.0912 MeV
# g^2_in = 2.93 MeV         ! reduced width of deuteron
# g^2_out = 0.0794 MeV      ! reduced width of neutron
res[2] <- 0.0912   # resonance energy
res[3] <-  2.93    # reduced width incoming
res[4] <- 0.0794   # reduced width outgoing
for (i in 1:length(obsx1)){
res[1] <- obsx1[i]
write.table(res, file="tdn_AD.in", quote=TRUE,
row.names=FALSE, col.names=FALSE)
# Load the fortran code needed to calculate S-factor curve
if(!is.loaded("tdn_AD_Sub"))
dyn.load("tdn_AD.so")
.Fortran("tdn_AD_Sub")
tab1 <- read.table("tdn_AD.out", header=FALSE)
errobsy1[i] <- 1
obsy1[i] <- rnorm( 1, tab1[1,2], errobsy1[i] )
}
######################################################################
# import jags package
library(rjags)
library(runjags)
library(R2jags)
library(mcmcplots)
load.module("glm")
load.module("nuclear")
#
######################################################################
cat('model {
# LIKELIHOOD
for (i in 1:length(obsx1)) {
obsy1[i] ~ dnorm(y1[i], pow(errobsy1[i], -2))
y1[i] <- sfactorTdn_fast(obsx1[i], e1, gin, gout)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
## Physical priors:
# Hyperpriors
##
e1 ~ dt(0, pow(2.5,-2), 1)T(0,)
gout ~ dgamma(0.5,0.5)
gin ~ dgamma(0.5+gout,0.5+gout)
#   gin <-  gin0 + gout
#  gin ~ dunif(0, 100)
#  gout ~ dunif(0, 100)
#  gin ~ dunif(0, 10)
#  gout ~ dunif(gin, 10)
#  gin ~ dgamma(0.5,100)
#  gout ~ dgamma(0.5,100)
#  gin ~ dgamma(0.5,rl1)
#  gout ~ dgamma(0.5,rl2)
#  rl1 ~ dunif(0,500)
#  rl2 ~ dunif(0,500)
#  gin ~ dchisqr(1)T(gout,)
#  gin ~ dchisqr(1)
#  gout ~ dchisqr(1)
}', file={f <- tempfile()})
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
n.adapt  <- 5000
n.update <- 1000
n.iter   <- 10000
n.chains <- 3
n.thin   <- 10
inits <- function () { list(e1 = runif(1,0,5),gin=runif(1,2,10),gout=runif(1,0.01,1)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
out <- jags(data = list('obsx1' = obsx1, ## jags wants all data in a list
'obsy1' = obsy1,
'errobsy1' = errobsy1),
inits = inits,
parameters = c("e1", "gin", "gout"),
model.file = f,
n.thin = 10,
n.chains = 3,
n.burnin = 40000,
n.iter = 75000)
out
######################################################################
cat('model {
# LIKELIHOOD
for (i in 1:length(obsx1)) {
obsy1[i] ~ dnorm(y1[i], pow(errobsy1[i], -2))
y1[i] <- sfactorTdn_fast(obsx1[i], e1, gin, gout)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
## Physical priors:
# Hyperpriors
##
e1 ~ dt(0, pow(2.5,-2), 1)T(0,)
gout ~ dgamma(0.5,0.5)
gin ~ dgamma(0.5,0.5+gout)
#   gin <-  gin0 + gout
#  gin ~ dunif(0, 100)
#  gout ~ dunif(0, 100)
#  gin ~ dunif(0, 10)
#  gout ~ dunif(gin, 10)
#  gin ~ dgamma(0.5,100)
#  gout ~ dgamma(0.5,100)
#  gin ~ dgamma(0.5,rl1)
#  gout ~ dgamma(0.5,rl2)
#  rl1 ~ dunif(0,500)
#  rl2 ~ dunif(0,500)
#  gin ~ dchisqr(1)T(gout,)
#  gin ~ dchisqr(1)
#  gout ~ dchisqr(1)
}', file={f <- tempfile()})
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
n.adapt  <- 5000
n.update <- 1000
n.iter   <- 10000
n.chains <- 3
n.thin   <- 10
inits <- function () { list(e1 = runif(1,0,5),gin=runif(1,2,10),gout=runif(1,0.01,1)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
out <- jags(data = list('obsx1' = obsx1, ## jags wants all data in a list
'obsy1' = obsy1,
'errobsy1' = errobsy1),
inits = inits,
parameters = c("e1", "gin", "gout"),
model.file = f,
n.thin = 10,
n.chains = 3,
n.burnin = 40000,
n.iter = 75000)
denplot(out)
out
traplot(out)
mcmcplot(out)
1/(2.5^2)
#
######################################################################
cat('model {
# LIKELIHOOD
for (i in 1:length(obsx1)) {
obsy1[i] ~ dnorm(y1[i], pow(errobsy1[i], -2))
y1[i] <- sfactorTdn_fast(obsx1[i], e1, gin, gout)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
## Physical priors:
# Hyperpriors
##
e1 ~ dt(0, pow(2.5,-2), 1)T(0,)
gout ~ dgamma(0.5,0.5)
gin ~ dgamma(0.5,0.5+gout)
#   gin <-  gin0 + gout
#  gin ~ dunif(0, 100)
#  gout ~ dunif(0, 100)
#  gin ~ dunif(0, 10)
#  gout ~ dunif(gin, 10)
#  gin ~ dgamma(0.5,100)
#  gout ~ dgamma(0.5,100)
#  gin ~ dgamma(0.5,rl1)
#  gout ~ dgamma(0.5,rl2)
#  rl1 ~ dunif(0,500)
#  rl2 ~ dunif(0,500)
#  gin ~ dchisqr(1)T(gout,)
#  gin ~ dchisqr(1)
#  gout ~ dchisqr(1)
}', file={f <- tempfile()})
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
n.adapt  <- 5000
n.update <- 1000
n.iter   <- 10000
n.chains <- 3
n.thin   <- 10
inits <- function () { list(e1 = runif(1,0,5),gin=runif(1,2,10),gout=runif(1,0.01,1)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
out <- jags(data = list('obsx1' = obsx1, ## jags wants all data in a list
'obsy1' = obsy1,
'errobsy1' = errobsy1),
inits = inits,
parameters = c("e1", "gin", "gout"),
model.file = f,
n.thin = 10,
n.chains = 6,
n.burnin = 30000,
n.iter = 60000)
denplot(out)
#
######################################################################
cat('model {
# LIKELIHOOD
for (i in 1:length(obsx1)) {
obsy1[i] ~ dnorm(y1[i], pow(errobsy1[i], -2))
y1[i] <- sfactorTdn_fast(obsx1[i], e1, gin, gout)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
## Physical priors:
# Hyperpriors
##
e1 ~ dt(0, pow(2.5,-2), 1)T(0,)
gout ~ dgamma(0.5,0.5)
gin ~ dgamma(0.5,0.5+gout)
#   gin <-  gin0 + gout
#  gin ~ dunif(0, 100)
#  gout ~ dunif(0, 100)
#  gin ~ dunif(0, 10)
#  gout ~ dunif(gin, 10)
#  gin ~ dgamma(0.5,100)
#  gout ~ dgamma(0.5,100)
#  gin ~ dgamma(0.5,rl1)
#  gout ~ dgamma(0.5,rl2)
#  rl1 ~ dunif(0,500)
#  rl2 ~ dunif(0,500)
#  gin ~ dchisqr(1)T(gout,)
#  gin ~ dchisqr(1)
#  gout ~ dchisqr(1)
}', file={f <- tempfile()})
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
n.adapt  <- 5000
n.update <- 1000
n.iter   <- 10000
n.chains <- 3
n.thin   <- 10
inits <- function () { list(e1 = runif(1,0,5),gin=runif(1,2,10),gout=runif(1,0.01,1)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
out <- jags(data = list('obsx1' = obsx1, ## jags wants all data in a list
'obsy1' = obsy1,
'errobsy1' = errobsy1),
inits = inits,
parameters = c("e1", "gin", "gout"),
model.file = f,
n.thin = 20,
n.chains = 6,
n.burnin = 30000,
n.iter = 60000)
denplot(out)
out
