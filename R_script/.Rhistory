require(rjags)
load.module("wiener")
install.packages("mclust")
26.59+2.64+70.71+12.97+8.99+15.66+0.46+3.91+0.11+43.60+5.91+0.17+36.42+1.09+53.59+1.6+28.88+24.87+24.96+3.59
366.72+300
27-21+1
7*100
9*50
9*55
9*60
31+5
1390.20/36
1390.20+1200+500
3090/36
require(INLA)
install.packages("INLA", repos="https://inla.r-inla-download.org/R/stable")
require(INLA)
x1 <- runif(100,0,1)
f <- function(x){(x+1)/(x^2-7)}
y <- rnorm(f(x),1)
x <- runif(100,0,1)
f <- function(x){(x+1)/(x^2-7)}
y <- rnorm(f(x),1)
plot(x,y)
x <- runif(100,0,1)
f <- function(x){exp(-x)+1}
y <- rnorm(f(x),1)
plot(x,y)
f(x)
y <- rnorm(100,f(x),1)
plot(x,y)
x <- runif(100,0,10)
f <- function(x){exp(-x)+1}
y <- rnorm(100,f(x),1)
plot(x,y)
x <- runif(100,0,50)
f <- function(x){exp(-x)+1}
y <- rnorm(100,f(x),1)
plot(x,y)
y
f(x)
x <- runif(100,0,50)
f <- function(x){exp(x)-1}
y <- rnorm(100,f(x),1)
plot(x,y)
x <- runif(100,0,10)
f <- function(x){exp(x)-1}
y <- rnorm(100,f(x),1)
plot(x,y)
x <- runif(100,0,10)
f <- function(x){0.5*exp(x)-1}
y <- rnorm(100,f(x),1)
plot(x,y)
x <- runif(100,0,10)
f <- function(x){0.5*exp(x/10)-1}
y <- rnorm(100,f(x),1)
plot(x,y)
x <- runif(100,0,10)
f <- function(x){0.5*exp(x/2)-1}
y <- rnorm(100,f(x),1)
plot(x,y)
data <- data.frame(x,y)
formula = y ~  alpha*exp(beta*x)-eta
result = inla(formula, family="Gaussian", data=data)
setwd("~/Documents/GitHub/JAGS_UNC/R_script")
setwd("~/Documents/GitHub/JAGS_UNC/R_script")
# tdn analysis
#
# purpose: ARTIFICIAL DATA
#
# - 3 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorTdn_fast(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
# Fortran code tdn_plot.f is needed in this R script for plotting the
# S-factor only
#
# Er=0.35779 MeV
# g_i^2=1.0085 MeV
# g_f^2=0.025425 MeV
######################################################################
# preparation: remove all variables from the work space
rm(list=ls())
#set.seed(123)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import jags package
library(rjags)
library(runjags)
library(R2jags)
library(mcmcplots)
library(magrittr)
library(dplyr)
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
#
######################################################################
## Read DATA GENERATION
ensamble <- read.csv("ensamble.csv",header = T)  %>%
filter(Stat!=0) %>%
filter(.,dat!="Lac05")
#index <- sample(seq(1:125),50,replace = F)
#ensamble <- ensamble[index,]
obsy = ensamble$S    # Response variable
obsx =  ensamble$E   # Predictors
erry = ensamble$Stat
model.data <- list(obsy = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble)    # Sample size
)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(sfactor3Hedp(obsx[i], e1, gin, gout),pow(tau, -2))
#obsy[i] ~ dnorm(sfactor3Hedp(obsx[i], e1, gin, gout), pow(tau, -2))
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
## Physical priors:
#
tau ~ dgamma(0.01,0.01)
e1 ~  dnorm(0.35,1)T(0,)
gout ~ dlnorm(log(0.02),0.5)
gin ~ dlnorm(log(1),0.5)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0,0.4),gin=runif(1,0.5,1.2),gout=runif(1,0.001,0.5)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout"),
model = textConnection(Model),
n.thin = 20,
n.chains = 6,
n.burnin = 7500,
n.iter = 15000)
mcmcChain <- as.mcmc(Normfit)[,-1]
library(sfsmisc)
library(plotrix)
library(emdbook)
library(magicaxis)
# first determine plot ranges
pdf("MCMCHe3dp.pdf",width=10,height=5,onefile=F)
par(mfcol=c(1,1), mar=c(4.0,7.0,1.0,6.0), oma=c(0.5,1.0,0.5,1.0), tck=0.02,
las=1)
xLim = c(2e-3,1)
yLim = c(0,20)
######################################################################
# plot axes only...add lines...then data
plot( 1, type="n", lwd=2 , col="black" , xlim=xLim, ylim=yLim,
axes=FALSE, main="", xlab = "", ylab = "",
cex=1.5 , cex.lab=1.3, cex.axis=1.0,
cex.main=1.0, log="x" )
# control distance between axis and label [line=...]
title(xlab="Energy (MeV)", line=2, cex.lab=1.3)
title(ylab="S-Factor (MeV b)", line=2, cex.lab=1.3)
# control distance tick mark labels and axis
# don't touch first number
# second number controls distance tick mark labels and axis
# don't touch third number
magaxis(mgp=c(0,0.2,0))
box()
# plot legend
##legend(0.12, 3e-7, legend=c("MA97", "SCH97", "CAS02", "BYS08"), pch=c(1, 0, 6, 5))
text(0.04, 15, labels=expression(paste(NULL^"3","He(d,p)",NULL^"4","He")), cex=1.3)
######################################################################
# PLOT BELIEVABLE S-FACTORS
# matrix samplesmat contains the samples from all n.chains with rows:
# i, a.scale,...
# !!! make sure to check the order of the parameters in the MCMC output !!!
samplesmat = as.matrix(mcmcChain)
nsamp = nrow(samplesmat)
# define grid of 201 x values on a log scale for plotting of credible solutions;
# lseq is appropriate for log scale
# xComb = lseq(xLim[1],xLim[2],length=201)
# calculate for these energies and the set of Bayesian samples for
# Er, g^2_i, g^2_f the S_factor curve using Fortran code
for ( i in round(seq(from=1,to=nsamp,length=1000)) ) {
# output samples to file for S-factor calculation; for each set of samples,
# the values for the 3 parameters are written to file on separate lines
cat(samplesmat[i,], fill=1, file="He3dp.in")
# Load the fortran code needed to calculate S-factor curve
if(!is.loaded("He3dp_pSub"))
dyn.load("He3dp_plot.so")
.Fortran("He3dp_pSub")
# read data from file
mydat <- read.table("He3dp.out", header=FALSE)
lines( mydat[,1], mydat[,2], col=adjustcolor("red", alpha=0.02))
}
######################################################################
# function for error bars;
# w is the width of perpendicular end bars on errors; set to zero
add.error.bars <- function(X,Y,dX,dY,w,col){
X0 = X
Y0 = (Y-dY)
X1 =X
Y1 = (Y+dY)
arrows(X0, Y0, X1, Y1, lwd=2, code=3, angle=90, length=w, col=col)
Y0 = Y
X0 = (X-dX)
Y1 =Y
X1 = (X+dX)
arrows(X0, Y0, X1, Y1, lwd=2, code=3, angle=90, length=w, col=col)
}
# add data - circles
points( obsx, obsy, col="black", pch=1, cex=1.2 )
add.error.bars(obsx, obsy, 0.0, erry, 0.0, col="black" )
dev.off()
denplot(Normfit,c("e1", "gin", "gout"),style="plain")
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(sfactor3Hedp(obsx[i], e1, gin, gout),pow(tau, -2))
#obsy[i] ~ dnorm(sfactor3Hedp(obsx[i], e1, gin, gout), pow(tau, -2))
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
## Physical priors:
#
tau ~ dgamma(0.01,0.01)
e1 ~   dlnorm(log(0.3),0.5)
gout ~ dlnorm(log(0.02),0.5)
gin ~ dlnorm(log(1),0.5)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0,0.3),gin=runif(1,0.5,1),gout=runif(1,0.001,0.4)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout"),
model = textConnection(Model),
n.thin = 10,
n.chains = 6,
n.burnin = 7500,
n.iter = 15000)
denplot(Normfit,c("e1", "gin", "gout"),style="plain")
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] ~ dnorm(sfactor3Hedp(obsx[i], e1, gin, gout),pow(tau, -2))
#obsy[i] ~ dnorm(sfactor3Hedp(obsx[i], e1, gin, gout), pow(tau, -2))
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
## Physical priors:
#
tau ~ dgamma(0.01,0.01)
e1 ~   dnorm(0.3,1)T(0,)
gout ~ dunif(0,0.5)
gin ~ dunif(gout,1.5)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0,0.3),gin=runif(1,0.5,1),gout=runif(1,0.001,0.4)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout"),
model = textConnection(Model),
n.thin = 10,
n.chains = 6,
n.burnin = 7500,
n.iter = 15000)
denplot(Normfit,c("e1", "gin", "gout"),style="plain")
mcmcChain <- as.mcmc(Normfit)[,-1]
# first determine plot ranges
pdf("MCMCHe3dp.pdf",width=10,height=5,onefile=F)
par(mfcol=c(1,1), mar=c(4.0,7.0,1.0,6.0), oma=c(0.5,1.0,0.5,1.0), tck=0.02,
las=1)
xLim = c(2e-3,1)
yLim = c(0,20)
######################################################################
# plot axes only...add lines...then data
plot( 1, type="n", lwd=2 , col="black" , xlim=xLim, ylim=yLim,
axes=FALSE, main="", xlab = "", ylab = "",
cex=1.5 , cex.lab=1.3, cex.axis=1.0,
cex.main=1.0, log="x" )
# control distance between axis and label [line=...]
title(xlab="Energy (MeV)", line=2, cex.lab=1.3)
title(ylab="S-Factor (MeV b)", line=2, cex.lab=1.3)
# control distance tick mark labels and axis
# don't touch first number
# second number controls distance tick mark labels and axis
# don't touch third number
magaxis(mgp=c(0,0.2,0))
box()
# plot legend
##legend(0.12, 3e-7, legend=c("MA97", "SCH97", "CAS02", "BYS08"), pch=c(1, 0, 6, 5))
text(0.04, 15, labels=expression(paste(NULL^"3","He(d,p)",NULL^"4","He")), cex=1.3)
######################################################################
# PLOT BELIEVABLE S-FACTORS
# matrix samplesmat contains the samples from all n.chains with rows:
# i, a.scale,...
# !!! make sure to check the order of the parameters in the MCMC output !!!
samplesmat = as.matrix(mcmcChain)
nsamp = nrow(samplesmat)
# define grid of 201 x values on a log scale for plotting of credible solutions;
# lseq is appropriate for log scale
# xComb = lseq(xLim[1],xLim[2],length=201)
# calculate for these energies and the set of Bayesian samples for
# Er, g^2_i, g^2_f the S_factor curve using Fortran code
for ( i in round(seq(from=1,to=nsamp,length=1000)) ) {
# output samples to file for S-factor calculation; for each set of samples,
# the values for the 3 parameters are written to file on separate lines
cat(samplesmat[i,], fill=1, file="He3dp.in")
# Load the fortran code needed to calculate S-factor curve
if(!is.loaded("He3dp_pSub"))
dyn.load("He3dp_plot.so")
.Fortran("He3dp_pSub")
# read data from file
mydat <- read.table("He3dp.out", header=FALSE)
lines( mydat[,1], mydat[,2], col=adjustcolor("red", alpha=0.02))
}
######################################################################
# function for error bars;
# w is the width of perpendicular end bars on errors; set to zero
add.error.bars <- function(X,Y,dX,dY,w,col){
X0 = X
Y0 = (Y-dY)
X1 =X
Y1 = (Y+dY)
arrows(X0, Y0, X1, Y1, lwd=2, code=3, angle=90, length=w, col=col)
Y0 = Y
X0 = (X-dX)
Y1 =Y
X1 = (X+dX)
arrows(X0, Y0, X1, Y1, lwd=2, code=3, angle=90, length=w, col=col)
}
# add data - circles
points( obsx, obsy, col="black", pch=1, cex=1.2 )
add.error.bars(obsx, obsy, 0.0, erry, 0.0, col="black" )
dev.off()
show(summary(mcmcChain, quantiles = c(0.025, 0.16, 0.5, 0.84, 0.975)))
