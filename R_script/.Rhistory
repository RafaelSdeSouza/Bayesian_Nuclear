setwd("~/Documents/GitHub/JAGS_UNC/R_script")
# tdn analysis
#
# purpose: ARTIFICIAL DATA
#
# - 3 parameters are assumed: Er, gamma_d^2, gamma_n^2 [e1, gin, gout]
#
# - uses the function sfactorTdn_fast(obsx1[i], e1, gin, gout), which
#   is a C++ version of a Fortran code that includes Coulomb wave
#   function calculations; JAGS has been recompiled with this C++ function
#
# Fortran code tdn_plot.f is needed in this R script for plotting the
# S-factor only
#
######################################################################
# preparation: remove all variables from the work space
rm(list=ls())
#set.seed(123)
######################################################################
# data input
# format: obsx, obsy, errobsy; the latter are the individual statistical
# errors of each datum [i]
#
# energy is in units of MeV, and the S-factor in MeVb;
######################################################################
# import jags package
library(rjags)
library(runjags)
library(R2jags)
library(mcmcplots)
library(magrittr)
library(dplyr)
## for block updating [we do not need to center predictor variables]
load.module("glm")
load.module("nuclear")
#
######################################################################
## Read DATA GENERATION
ensamble <- read.csv("ensamble.csv",header = T)  %>%
mutate(Stat=replace(Stat,Stat==0, 0.1))
obsy = ensamble$S    # Response variable
obsx =  ensamble$E   # Predictors
erry = ensamble$Stat
model.data <- list(obsy = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble)    # Sample size
)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] <- sfactor3Hedp(obsx[i], e1, gin, gout)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
## Physical priors:
#
e1 ~ dt(0, pow(2.5,-2), 1)T(0,)
#    e1 ~ dunif(1e-3,10)
#   gout ~ dgamma(0.5,0.5)
#   gin ~ dgamma(0.5,0.5+gout)
gout ~ dunif(1e-3,50)
gin ~  dunif(gout,100)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0,10),gin=runif(1,4,10),gout=runif(1,0.001,3)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout"),
model = textConnection(Model),
n.thin = 10,
n.chains = 5,
n.burnin = 7500,
n.iter = 15000)
denplot(Normfit,c("e1", "gin", "gout"),style="plain")
mcmcplot(Normfit)
ensamble
sample(50,1,125,replace = F)
sample(seq(1:125),50,replace = F)
index <- sample(seq(1:125),50,replace = F)
ensamble <- ensamble[index,]
obsy = ensamble$S    # Response variable
obsx =  ensamble$E   # Predictors
erry = ensamble$Stat
model.data <- list(obsy = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble)    # Sample size
)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] <- sfactor3Hedp(obsx[i], e1, gin, gout)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
## Physical priors:
#
e1 ~ dt(0, pow(2.5,-2), 1)T(0,)
#    e1 ~ dunif(1e-3,10)
#   gout ~ dgamma(0.5,0.5)
#   gin ~ dgamma(0.5,0.5+gout)
gout ~ dunif(1e-3,50)
gin ~  dunif(gout,100)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0,10),gin=runif(1,4,10),gout=runif(1,0.001,3)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout"),
model = textConnection(Model),
n.thin = 10,
n.chains = 5,
n.burnin = 7500,
n.iter = 15000)
denplot(Normfit,c("e1", "gin", "gout"),style="plain")
Normfit
traplot(Normfit,c("e1", "gin", "gout"),style="plain")
Normfit
######################################################################
## Read DATA GENERATION
ensamble <- read.csv("ensamble.csv",header = T)  %>%
mutate(Stat=replace(Stat,Stat==0, 0.1))
#index <- sample(seq(1:125),50,replace = F)
#ensamble <- ensamble[index,]
obsy = ensamble$S    # Response variable
obsx =  ensamble$E   # Predictors
erry = ensamble$Stat
model.data <- list(obsy = obsy,    # Response variable
obsx =  obsx,   # Predictors
erry = erry,
N = nrow(ensamble)    # Sample size
)
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] <- sfactor3Hedp(obsx[i], e1, gin, gout)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
## Physical priors:
#
e1 ~ dt(0, pow(2.5,-2), 1)T(0,)
#    e1 ~ dunif(1e-3,10)
gout ~ dgamma(0.5,0.5)
gin ~ dgamma(0.5,0.5+gout)
#    gout ~ dunif(1e-3,50)
#    gin ~  dunif(gout,100)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0,10),gin=runif(1,4,10),gout=runif(1,0.001,3)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout"),
model = textConnection(Model),
n.thin = 10,
n.chains = 5,
n.burnin = 5000,
n.iter = 15000)
denplot(Normfit,c("e1", "gin", "gout"),style="plain")
ensamble
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
y[i] <- 2*sfactor3Hedp(obsx[i], e1, gin, gout)
}
# PRIORS
# e1, gin, gout are defined as in tdn.f (by Alain Coc):
# resonance energy, initial reduced width, final reduced
# width;
## Physical priors:
#
e1 ~ dt(0, pow(2.5,-2), 1)T(0,)
#    e1 ~ dunif(1e-3,10)
gout ~ dgamma(0.5,0.5)
gin ~ dgamma(0.5,0.5+gout)
#    gout ~ dunif(1e-3,50)
#    gin ~  dunif(gout,100)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0,10),gin=runif(1,4,10),gout=runif(1,0.001,3)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- jags(data = model.data,
inits = inits,
parameters = c("e1", "gin", "gout"),
model = textConnection(Model),
n.thin = 10,
n.chains = 5,
n.burnin = 5000,
n.iter = 15000)
denplot(Normfit,c("e1", "gin", "gout"),style="plain")
Normfit
